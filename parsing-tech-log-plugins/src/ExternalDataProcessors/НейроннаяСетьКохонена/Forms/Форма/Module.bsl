&НаКлиенте
Перем СтарыеКолонки;


&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	Данные = новый Структура("НаборТочек,НейроннаяСетьКохонена");
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	ОбновитьHTML();
КонецПроцедуры



&НаСервере
Процедура ОбучитьНаСервере()
	
	input = Новый Массив;
	input.Добавить(1);
	input.Добавить(2); 
	
	ОбработкаОб = РеквизитФормыВЗначение("Объект");
	KohonenNetwork = ОбработкаОб.class_KohonenNetwork(2,2);
	ОбработкаОб.Study(input,1);
	
	input = Новый Массив;
	input.Добавить(3);
	input.Добавить(-1); 
	
	ОбработкаОб.Study(input,0);
	
	//Установить_class_KohonenNetwork.
	НейроннаяСетьКохонена = ОбработкаОб.ПолучитьСетьКохонена(); 
	
	
КонецПроцедуры

&НаКлиенте
Процедура Обучить(Команда)
	ОбучитьНаСервере();
КонецПроцедуры

&НаСервере
Процедура ОбучитьБезУчителяНаСервере()
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	НаборТочек = Данные.НаборТочек;
	НейроннаяСетьКохонена = Данные.НейроннаяСетьКохонена;
	
	Если НаборТочек=Неопределено Тогда
		Сообщить("Не создан набор!");
		Возврат;
	КонецЕсли;
	
	ЭпохОбучения = ЭпохОбучения +1;
	
	ОбработкаОб = РеквизитФормыВЗначение("Объект");
	
	Если НейроннаяСетьКохонена=Неопределено Тогда
		НейроннаяСетьКохонена = ОбработкаОб.class_KohonenNetwork(2,ЧислоНейронов);		
	КонецЕсли;
	ОбработкаОб.УстановитьСкоростьОбучения(СкоростьОбучения);
	
	// одна эпоха
	Для каждого кластер из НаборТочек Цикл
		ОбработкаОб.StudySOM(НейроннаяСетьКохонена,кластер,ЭпохОбучения);
	КонецЦикла;     	
	
	
	//НейроннаяСетьКохонена = ОбработкаОб.ПолучитьСетьКохонена(); 
	
	Данные.Вставить("НейроннаяСетьКохонена", НейроннаяСетьКохонена);
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура ОбучитьБезУчителя(Команда)
	тмп = Ложь;
	Для ш=0 по ШагПоЭпохам Цикл
		ОбучитьБезУчителяНаСервере();
	КонецЦикла;
	ОтобразитьГрафикТочекHTML();
КонецПроцедуры

&НаСервере
Процедура СоздатьНаборыТочекНаСервере()
	
	ЭпохОбучения = 0;
	ТаблицаСвязей.Очистить();
	ГСЧ = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	
	
	МассивЦентровТочек = новый Массив;
	Если РандомныеЦентры = Истина Тогда
		Для ш=0 по 6 Цикл
			x = (ГСЧ.СлучайноеЧисло(0, 40)-20);
			y = (ГСЧ.СлучайноеЧисло(0, 40)-20);
			МассивЦентровТочек.Добавить(Новый Структура("x,y",x,y));
		КонецЦикла;
	Иначе
		МассивЦентровТочек.Добавить(Новый Структура("x,y",0,20));
		МассивЦентровТочек.Добавить(Новый Структура("x,y",20,0));
		МассивЦентровТочек.Добавить(Новый Структура("x,y",-20,-20));
		МассивЦентровТочек.Добавить(Новый Структура("x,y",20,20));
		МассивЦентровТочек.Добавить(Новый Структура("x,y",-20,-5));
		МассивЦентровТочек.Добавить(Новый Структура("x,y",-1,1));
	КонецЕсли;
	
	
	НаборТочек = Новый Массив;
	МаксимальныйНабор = 20;
	
	Для каждого центр из МассивЦентровТочек Цикл
		МассивКластера = новый Массив;
		Для ш=0 по МаксимальныйНабор Цикл 			
			dx = (ГСЧ.СлучайноеЧисло(0, 10)-5)/2;
			dy = (ГСЧ.СлучайноеЧисло(0, 10)-5)/2;
			МассивКластера.Добавить(новый Структура("x,y",центр.x+dx,центр.y+dy));
		КонецЦикла;
		НаборТочек.Добавить(МассивКластера);
	КонецЦикла;
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	Данные.НаборТочек = НаборТочек;
	Данные.НейроннаяСетьКохонена = Неопределено;
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
	//ПостроитьГрафикТочек();
	
КонецПроцедуры


&НаСервере
Процедура СформироватьДанныеГрафикТочекHTML()	
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	НаборТочек = Данные.НаборТочек;
	НейроннаяСетьКохонена = Данные.НейроннаяСетьКохонена;
	
	array = "
	|var points = {
	|mode: 'markers',
	|type: 'scatter',
	|name: 'Points',
	|marker: { size: 8 },";
	
	
	// точки
	x_str = "";
	y_str = "";
	Если НЕ НаборТочек=НЕопределено Тогда
		Для каждого кластер из НаборТочек Цикл
			Для каждого точка из кластер Цикл
				
				x_str = x_str +?(x_str="","",",")+ XMLСтрока(точка.x);
				y_str = y_str +?(y_str="","",",")+ XMLСтрока(точка.y);
				
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	array = array+"
	|x: ["+x_str+"],
	|y: ["+y_str+"]";
	array = array+"
	|};";
	
	//ТаблицаСвязей.Очистить();
	
	
	// кластеры
	Если НЕ НейроннаяСетьКохонена=НЕопределено Тогда
		
		array = array+ "
		|var som = {
		|mode: 'markers',
		|type: 'scatter',
		|name: 'Clusters',
		|marker: { size: 12 },";
		
		x_str = "";
		y_str = "";		
		Для каждого нейрон из НейроннаяСетьКохонена._neurons Цикл
			
			x = НейроннаяСетьКохонена._links.Получить(нейрон.IncomingLinks[0]).Weight;
			y = НейроннаяСетьКохонена._links.Получить(нейрон.IncomingLinks[1]).Weight;
			
			x_str = x_str +?(x_str="","",",")+ XMLСтрока(x);
			y_str = y_str +?(y_str="","",",")+ XMLСтрока(y);
			
			стр_н = ТаблицаСвязей.Добавить();
			стр_н.связь = нейрон.IncomingLinks[0];
			стр_н.вес = НейроннаяСетьКохонена._links.Получить(нейрон.IncomingLinks[0]).Weight;
			стр_н.эпоха = ЭпохОбучения;
			мОтбор = новый Структура("связь,эпоха",стр_н.связь,ЭпохОбучения-1);
			н_строки = ТаблицаСвязей.НайтиСтроки(мОтбор);
			Если н_строки.Количество()=1 Тогда
				стр_н.дельта = стр_н.вес-н_строки[0].вес;
			КонецЕсли;
			
			стр_н = ТаблицаСвязей.Добавить();
			стр_н.связь = нейрон.IncomingLinks[1];
			стр_н.вес = НейроннаяСетьКохонена._links.Получить(нейрон.IncomingLinks[1]).Weight;			
			стр_н.эпоха = ЭпохОбучения;
			мОтбор = новый Структура("связь,эпоха",стр_н.связь,ЭпохОбучения-1);
			н_строки = ТаблицаСвязей.НайтиСтроки(мОтбор);
			Если н_строки.Количество()=1 Тогда
				стр_н.дельта = стр_н.вес-н_строки[0].вес;
			КонецЕсли;			
			
		КонецЦикла;
		
		array = array+"
		|x: ["+x_str+"],
		|y: ["+y_str+"]";
		array = array+"
		|};";
		
		
		мОтбор = новый Структура("Эпоха",ЭпохОбучения);
		н_строки = ТаблицаСвязей.НайтиСтроки(мОтбор);
		ОшибкаОбучения = 0;
		Для каждого стр из н_строки Цикл
			ОшибкаОбучения = ОшибкаОбучения + ?(стр.дельта<0,-стр.дельта,стр.дельта);
		КонецЦикла;
		
		// таблица нейронов
		ТаблицаНейронов.Очистить();
		
		Для каждого нейрон из НейроннаяСетьКохонена._neurons Цикл
			стр_н = ТаблицаНейронов.Добавить();
			ЗаполнитьЗначенияСвойств(стр_н,нейрон);
			
			
			Для каждого связь из нейрон.IncomingLinks Цикл
				стр_н.Weights = стр_н.Weights + связь+":"+
				НейроннаяСетьКохонена._links.Получить(связь).Weight+" ";
			КонецЦикла;
		КонецЦикла;
		
	Иначе
		
		array = array+ "
		|var som = {
		|mode: 'markers',
		|type: 'scatter',
		|name: 'Clusters',
		|marker: { size: 12 },
		|x: [0],
		|y: [0]
		|};";
		
		
	КонецЕсли;
	
	
	
КонецПроцедуры


&НаКлиенте
Процедура ОтобразитьГрафикТочекHTML()
	
	
	
	
	ПолеChart = Элементы.HTML.Документ.getElementById("myDiv");
	
	Если ПолеChart=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СформироватьДанныеГрафикТочекHTML();
	
	Если array="" Тогда
		Возврат;
	КонецЕсли;
	
	JS=array+"var data = [ points, som ];";	
	
	
	delement = Элементы.HTML.Документ.getElementById("d");
	delement.value = JS;
	
	//element = Элементы.HTML.Документ.getElementById("t");
	//element.onClick();	
	Элементы.HTML.Документ.defaultView.update_grath();
	
	
КонецПроцедуры

&НаКлиенте
Процедура СоздатьНаборыТочек(Команда)
	СоздатьНаборыТочекНаСервере();
	ОтобразитьГрафикТочекHTML();
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	ПроверитьИнициализироватьБиблиотеки("js_plotly");
	ПроверитьИнициализироватьБиблиотеки("html_plotly",Ложь,"HTML");
	ПроверитьИнициализироватьБиблиотеки("html_plotly",Ложь,"ГрафикHTML");
	
	//ТекстовыйДокумент = новый ТекстовыйДокумент;
	//ТекстовыйДокумент.Прочитать("C:/temp/test2.html");
	//HTML = ТекстовыйДокумент.ПолучитьТекст();
	//HTML="https://plot.ly/javascript/line-charts/";
	//HTML = "<html><head><script type='text/javascript'>function hello(){alert('hello');};</script></head><body>test</body></html>";
	
	ШагПоЭпохам = 2;
	СкоростьОбучения = 0.05;
	ЧислоНейронов = 2;
	
	СоздатьСвойстваКнопок();
	
	стр_н = Входы.Добавить();
	стр_н.id=0;
	стр_н = Входы.Добавить();
	стр_н.id=1;
	стр_н = Входы.Добавить();
	стр_н.id=2;
	
КонецПроцедуры


&НаКлиенте
Процедура ОбновитьДиаграмму(Команда)
	ОтобразитьГрафикТочекHTML();
КонецПроцедуры

Процедура ОбновитьHTML()
	
	Возврат;
	
	ОбработкаОб = РеквизитФормыВЗначение("Объект");
	текст = ОбработкаОб.ПолучитьМакет("html_google").ПолучитьТекст();
	html = текст;
	
КонецПроцедуры

&НаКлиенте
Процедура HTMLДокументСформирован(Элемент)
КонецПроцедуры

&НаСервере
Процедура СоздатьНаборТочекРандомНаСервере()
	ЭпохОбучения = 0;
	ТаблицаСвязей.Очистить();
	
	МассивЦентровТочек = новый Массив;
	МассивЦентровТочек.Добавить(Новый Структура("x,y",0,0));
	
	
	
	НаборТочек = Новый Массив;
	МаксимальныйНабор = 100;
	
	ГСЧ = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	
	Для каждого центр из МассивЦентровТочек Цикл
		МассивКластера = новый Массив;
		Для ш=0 по МаксимальныйНабор Цикл 			
			dx = (ГСЧ.СлучайноеЧисло(0, 60)-30)/2;
			dy = (ГСЧ.СлучайноеЧисло(0, 60)-30)/2;
			МассивКластера.Добавить(новый Структура("x,y",центр.x+dx,центр.y+dy));
		КонецЦикла;
		НаборТочек.Добавить(МассивКластера);
	КонецЦикла;
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	Данные.НаборТочек = НаборТочек;
	Данные.НейроннаяСетьКохонена = Неопределено;
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура СоздатьНаборТочекРандом(Команда)
	СоздатьНаборТочекРандомНаСервере();
	ОтобразитьГрафикТочекHTML();
КонецПроцедуры





&НаСервере
Процедура ВыполнитьДелениеНаСервере()
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	НаборТочек = Данные.НаборТочек;
	НейроннаяСетьКохонена = Данные.НейроннаяСетьКохонена;
	
	ОбработкаОб = РеквизитФормыВЗначение("Объект");
	ОбработкаОб.РазбитьНаДва(НейроннаяСетьКохонена);	
	
	Данные.Вставить("НейроннаяСетьКохонена", НейроннаяСетьКохонена);
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьДеление(Команда)
	ВыполнитьДелениеНаСервере();
	ОтобразитьГрафикТочекHTML();
КонецПроцедуры

&НаСервере
Процедура ВыполнитьСлияниеНаСервере()
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	НаборТочек = Данные.НаборТочек;
	НейроннаяСетьКохонена = Данные.НейроннаяСетьКохонена;
	
	ОбработкаОб = РеквизитФормыВЗначение("Объект");
	ОбработкаОб.УдалитьМертвыеНейроны(НейроннаяСетьКохонена);	
	
	Данные.Вставить("НейроннаяСетьКохонена", НейроннаяСетьКохонена);
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьСлияние(Команда)
	ВыполнитьСлияниеНаСервере();
	ОтобразитьГрафикТочекHTML();	
КонецПроцедуры

&НаСервере
Процедура СброситьНейроннуюСетьНаСервере()
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	НаборТочек = Данные.НаборТочек;
	НейроннаяСетьКохонена = Данные.НейроннаяСетьКохонена;
	
	ЭпохОбучения = 0;
	
	ОбработкаОб = РеквизитФормыВЗначение("Объект");
	
	НейроннаяСетьКохонена = ОбработкаОб.class_KohonenNetwork(2,ЧислоНейронов);		
	
	Данные.Вставить("НейроннаяСетьКохонена", НейроннаяСетьКохонена);
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура СброситьНейроннуюСеть(Команда)
	СброситьНейроннуюСетьНаСервере();
	ОтобразитьГрафикТочекHTML();
КонецПроцедуры


&НаСервере
Процедура СеткаИзНейроновНаСервере()
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	НаборТочек = Данные.НаборТочек;
	НейроннаяСетьКохонена = Данные.НейроннаяСетьКохонена;
	
	ЭпохОбучения = 0;
	
	
	ОбработкаОб = РеквизитФормыВЗначение("Объект");
	
	НейроннаяСетьКохонена = ОбработкаОб.class_KohonenNetworkMap(2,5,5,40,40);		
	
	Данные.Вставить("НейроннаяСетьКохонена", НейроннаяСетьКохонена);
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура СеткаИзНейронов(Команда)
	СеткаИзНейроновНаСервере();
	ОтобразитьГрафикТочекHTML();
КонецПроцедуры


#Область Макеты

&НаКлиенте
Процедура ПроверитьИнициализироватьБиблиотеки(Знач ИмяБиблиотеки, Знач ЭтоБиблиотека = Истина, Знач ИмяПоля="",  Знач КаталогВыгрузки="")
	
	
	КорневойПутьПроекта = "SOM";
	
	НеобходимоИнициализироватьБиблиотеку = Истина;
	ПутьКБиблиотеке = "";//ЭтаФорма[ИмяБиблиотеки+"Путь"];
	ПутьККорнюПроекта = "";
	ПутьКФайлуБиблиотеки = "";
	МакетБиблиотеки = Неопределено;
	
	// определим каталоги
	Если НЕ ЗначениеЗаполнено(КаталогВыгрузки) Тогда
		ПутьКБиблиотеке = КаталогВременныхФайлов()+КорневойПутьПроекта+"\"+ИмяБиблиотеки+"\"; 
		ПутьККорнюПроекта = КаталогВременныхФайлов()+КорневойПутьПроекта+"\";
	Иначе
		ПутьКБиблиотеке = КаталогВыгрузки+КорневойПутьПроекта+"\"+ИмяБиблиотеки+"\"; 
		ПутьККорнюПроекта = КаталогВыгрузки+КорневойПутьПроекта+"\";
	КонецЕсли;
	
	// определим пути
	Если ЭтоБиблиотека=Истина Тогда
		ПутьКФайлуБиблиотеки = ПутьКБиблиотеке+ИмяБиблиотеки+".js";
	Иначе
		ПутьКФайлуБиблиотеки = ПутьККорнюПроекта+ИмяБиблиотеки+".html";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПутьКФайлуБиблиотеки) Тогда
		Файл = новый Файл(ПутьКФайлуБиблиотеки);
		НеобходимоИнициализироватьБиблиотеку = НЕ Файл.Существует();
	КонецЕсли;
	
	Если НеобходимоИнициализироватьБиблиотеку Тогда 		
		
		СоздатьКаталог(ПутьККорнюПроекта);
		Если ЭтоБиблиотека=Истина Тогда
			СоздатьКаталог(ПутьКБиблиотеке);
		КонецЕсли;
		
		// скопируем в каталог файлы из архива
		МакетБиблиотеки = ПолучитьМакетНаСервере(ИмяБиблиотеки);
		
		Если МакетБиблиотеки<>Неопределено Тогда
			// сохраняем и распаковываем редактор
			МакетБиблиотеки.Записать(ПутьКФайлуБиблиотеки);
		Иначе
			ПутьКБиблиотеке = "";
			Сообщить("Неизвестаная ошибка сохранения макета...");
		КонецЕсли;
		
	КонецЕсли;
	
	// Загрузим файл редактора
	Если ЭтоБиблиотека=Ложь Тогда
		//ДвоичныеДанные = новый ДвоичныеДанные(ПутьКФайлуБиблиотеки);
		ИмяJQuery = "./jquery/jquery.js";
		ИмяPlotly = "./plotly-latest.min.js";
		ИмяGoogle = "./loader.js";
		ПутьКJQuqry = ПутьККорнюПроекта+"\jquery\jquery.js";
		ПутьКPlotly = ПутьККорнюПроекта+"\js_plotly\js_plotly.js";
		ПутьКGoogle = ПутьККорнюПроекта+"\js_google_loader\js_google_loader.js";
		ТекстовыйДокумент = новый ТекстовыйДокумент;
		ТекстовыйДокумент.Прочитать(ПутьКФайлуБиблиотеки);
		WebView = ТекстовыйДокумент.ПолучитьТекст();
		WebView = СтрЗаменить(WebView,ИмяGoogle,ПутьКGoogle);
		WebView = СтрЗаменить(WebView,ИмяJQuery,ПутьКJQuqry);
		WebView = СтрЗаменить(WebView,ИмяPlotly,ПутьКPlotly);
		Если Найти(WebView,"<!-- &скрипт -->") Тогда
			Скрипт = новый ТекстовыйДокумент;
			Скрипт.Прочитать(ПутьККорнюПроекта+"\js_plotly\js_plotly.js");
			WebView = СтрЗаменить(WebView,"<!-- &скрипт -->",Скрипт.ПолучитьТекст());
		КонецЕсли;
		
		ЭтаФорма[ИмяПоля] = WebView;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция - Получить макет на сервере
//
// Параметры:
//  ИмяМакета	 - строка	 - имя макета
// 
// Возвращаемое значение:
// макет  - макет
//
&НаСервере
Функция ПолучитьМакетНаСервере(ИмяМакета)
	Макет = Неопределено;
	Попытка
		ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
		Макет = ОбработкаОбъект.ПолучитьМакет(ИмяМакета);
	Исключение
		Сообщить(ОписаниеОшибки());		
	КонецПопытки;
	Возврат Макет;
КонецФункции

#КонецОбласти


&НаКлиенте
Процедура ПутьКДаннымНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие); 
	Диалог.Заголовок = "Выберите файл"; 
	Если ЗначениеЗаполнено(ПутьКДанным) Тогда
		Диалог.Каталог = ПолучитьКаталогПоПутиФайла(ПутьКДанным);
	КонецЕсли;
	Диалог.ПолноеИмяФайла = ""; 
	Фильтр = "CSV-файл (*.csv)|*.csv"; 
	Диалог.Фильтр = Фильтр; 
	Диалог.МножественныйВыбор = Ложь; 
	ВыборФайлаОткрытияФайла = новый ОписаниеОповещения("ВыборФайлаОткрытияФайла",ЭтотОбъект,новый Структура("ИмяРеквизита","ПутьКДанным"));
	Диалог.Показать(ВыборФайлаОткрытияФайла);
КонецПроцедуры

&НаКлиенте
Функция  ПолучитьКаталогПоПутиФайла(Знач ПутьКФайлу)
	Файл = новый Файл(ПутьКФайлу);
	Возврат Файл.Путь;	
КонецФункции

&НаКлиенте
Процедура ВыборФайлаОткрытияФайла(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	
	Если ВыбранныеФайлы <> Неопределено И ВыбранныеФайлы.Количество() > 0 Тогда
		ЭтаФорма[ДополнительныеПараметры.ИмяРеквизита] = ВыбранныеФайлы[0]; 
	КонецЕсли; 
	
КонецПроцедуры


#Область ЗагрузкаСохранениеCSV

&НаКлиенте
Функция РазобратьФайлВТаблицуCSV(ПутьКФайлу) Экспорт
	
	ИмяФайлаДляРазбора 	= ПутьКФайлу;
	
	
	//пропуск пустых файлов
	ФайлТЖ = Новый Файл(ИмяФайлаДляРазбора);
	РазмерФайла = ФайлТЖ.Размер();
	Если РазмерФайла <=3 Тогда
		Сообщить("Файл пустой!");
		Возврат 0;
	КонецЕсли;
	
	ДатаНачалаЧтения = ТекущаяДата();
	
	Текст = Новый ЧтениеТекста(ИмяФайлаДляРазбора, КодировкаТекста.ANSI, Символы.ВК + Символы.ПС, "", Ложь);
	
	// Всегда читаем перую строку для свойств
	СтрокаТекста = Текст.ПрочитатьСтроку();
	ПрочитаноСтрок = 0;
	
	// разделение по csv запятая
	СтрокаТекста = СтрЗаменить(СтрокаТекста,"(PDH-CSV 4.0) (RTZ 2 (","Время");
	МассивИменСвойств = СтрРазделить(СтрокаТекста,",",Ложь); 
	
	// нормализуем параметры
	Для ш=0 по МассивИменСвойств.ВГраница() Цикл
		МассивИменСвойств[ш] = СтрЗаменить(МассивИменСвойств[ш],"""","");
		Если Найти(МассивИменСвойств[ш],"\\") Тогда
			МассивЧастей = СтрРазделить(СтрЗаменить(МассивИменСвойств[ш],"\\",""),"\");
			Если Найти(МассивЧастей[1],":") Тогда
				МассивЧастейСКЛ = СтрРазделить(МассивЧастей[1],":");
				МассивЧастей[1]=СокрЛП(МассивЧастейСКЛ[1]);
			КонецЕсли;
			МассивИменСвойств[ш] = СокрЛП(МассивЧастей[1]+"\"+МассивЧастей[2]);
		КонецЕсли;
	КонецЦикла;
	
	// Сформируем таблицу, данных
	Колонки = новый Массив;
	МассивТипов = новый Массив;
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Дата"));
	МассивТипов.Добавить(Тип("Булево"));
	КС = Новый КвалификаторыСтроки(20);
	КЧ = Новый КвалификаторыЧисла(20,10);
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов, , ,КЧ, КС);
	ОписаниеЧисло = Новый ОписаниеТипов("Число", , ,КЧ);	
	Если НайтиИмяВходаТаблицыДанных("№")="" Тогда
		Колонки.Добавить(новый Структура("Имя,ТипЗначения,Ширина,Заголовок","НомерСтроки",ОписаниеЧисло,10,"№"));
	КонецЕсли;
	Если НайтиИмяВходаТаблицыДанных("t")="" Тогда
		Колонки.Добавить(новый Структура("Имя,ТипЗначения,Ширина,Заголовок","ВремяЧислом",ОписаниеЧисло,10,"t"));
	КонецЕсли;
	ш=0;
	Для каждого стр из МассивИменСвойств Цикл
		
		Если стр="t" Тогда
			Попытка
				Колонки.Добавить(новый Структура("Имя,ТипЗначения,Ширина,Заголовок","ВремяЧислом",ОписаниеТипов,10,стр));
			Исключение
			КонецПопытки;
		ИначеЕсли стр="№" Тогда
			Попытка
				Колонки.Добавить(новый Структура("Имя,ТипЗначения,Ширина,Заголовок","НомерСтроки",ОписаниеТипов,10,стр));
			Исключение
			КонецПопытки;
		Иначе
			Колонки.Добавить(новый Структура("Имя,ТипЗначения,Ширина,Заголовок","Свойство"+XMLСтрока(ш),ОписаниеТипов,10,стр));
		КонецЕсли;	
		ш=ш+1;
	КонецЦикла;
	
	Если СтарыеКолонки=Неопределено Тогда
		СтарыеКолонки = новый Массив;
	КонецЕсли;
	
	КолонкиТаблицыДанных.Очистить();
	Для каждого стр из Колонки Цикл
		стр_н = КолонкиТаблицыДанных.Добавить();
		ЗаполнитьЗначенияСвойств(стр_н,стр);
	КонецЦикла;
	
	СоздатьДинамическиеКолонкиТаблицы("ТаблицаДанных",Колонки,СтарыеКолонки);
	
	СтарыеКолонки = Колонки;
	
	
	ПозиционироватьЧтениеНаСтрокуФайла(Текст, ПрочитаноСтрок);
	
	//продолжаем чтение с позиции СостояниеЧтения.ПрочитаноСтрок
	СтрокаТекста = Текст.ПрочитатьСтроку();
	
	Пока СтрокаТекста <> Неопределено ИЛИ НЕ ЗначениеЗаполнено(СтрокаТекста) Цикл
		
		// Проверяем, является ли следующая строка начальной строкой журнала
		СледующаяСтрока = Текст.ПрочитатьСтроку();
		
		Если СледующаяСтрока = Неопределено ИЛИ НЕ ЗначениеЗаполнено(СледующаяСтрока) Тогда
			Прервать;	
		КонецЕсли;
		
		ПрочитаноСтрок = ПрочитаноСтрок + 1;
		
		стр_н = ТаблицаДанных.Добавить();
		стр_н.НомерСтроки = ПрочитаноСтрок;
		
		МассивЗначенийСвойств = СтрРазделить(СледующаяСтрока,",",Ложь);
		
		Для ш=0 по МассивЗначенийСвойств.ВГраница() Цикл
			
			ИмяСвойства = МассивИменСвойств[ш]; 			
			
			ЗначениеСвойства = 0;
			
			Попытка
				
				Если ЭтоДата(МассивЗначенийСвойств[ш]) Тогда
					ЗначениеСвойства = ПрочитатьДату(МассивЗначенийСвойств[ш]);
				Иначе 					
					// очень маленькие будут 0
					Если Найти(МассивЗначенийСвойств[ш],"e-") Тогда
						ЗначениеСвойства = 0;
					Иначе
						ЗначениеСвойства = Число(СтрЗаменить(МассивЗначенийСвойств[ш],"""",""));
					КонецЕсли;
				КонецЕсли;
				
				стр_н["Свойство"+XMLСтрока(ш)] = ЗначениеСвойства; 
				
			Исключение
				
				Сообщить(ОписаниеОшибки());				
				
			КонецПопытки;
			
			
		КонецЦикла;
		
		СтрокаТекста = СледующаяСтрока;
	КонецЦикла;
	
	Текст.Закрыть();
	
	
	// обработаем время в число
	Если ТаблицаДанных.Количество()>0 Тогда
		Попытка			
			// найдем мин и макс время
			МинДата = ТаблицаДанных[0].Свойство0;
			МаксДата = МинДата;
			Для каждого стр из ТаблицаДанных Цикл
				Если МинДата>стр.Свойство0 Тогда
					МинДата = стр.Свойство0;
				КонецЕсли;
				Если МаксДата<стр.Свойство0 Тогда
					МаксДата = стр.Свойство0;
				КонецЕсли;			
			КонецЦикла;
			// посчитаем числом
			Для каждого стр из ТаблицаДанных Цикл
				стр.ВремяЧислом = стр.Свойство0-МинДата;
			КонецЦикла;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат 0;
КонецФункции

&НаКлиенте
Функция ЭтоДата(ДатаСтрокой) 
	
	// формат 2019-04-26T11:24:04
	Если Найти(ДатаСтрокой,"T") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,"-") Тогда
		Возврат Истина;
		// Формат 04/26/2019 11:24:49.150
	ИначеЕсли Найти(ДатаСтрокой,"/") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,".") И Найти(ДатаСтрокой," ") Тогда
		Возврат Истина;
	КонецЕсли;	
	
	Возврат Ложь;
	
КонецФункции

&НаКлиенте
Функция ПрочитатьДату(ДатаСтрокой)
	
	ДатаСобытия = Дата(1,1,1);
	
	// формат 2019-04-26T11:24:04
	Если Найти(ДатаСтрокой,"T") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,"-") Тогда
		Попытка
			ДатаСобытия = Дата(ДатаСтрокой);
		Исключение
		КонецПопытки;
	// Формат 04/26/2019 11:24:49.150
	ИначеЕсли Найти(ДатаСтрокой,"/") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,".") И Найти(ДатаСтрокой," ") Тогда
		
		// Первая всегда дата
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"""","");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"/","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,":","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,".","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой," ","#");
		
		Попытка
			МассивЧастейДаты = СтрРазделить(ДатаСтрокой,"#",Ложь);
			Год = Число(МассивЧастейДаты[2]);
			Месяц = Число(МассивЧастейДаты[0]);
			День = Число(МассивЧастейДаты[1]);
			Час = Число(МассивЧастейДаты[3]);
			Минута = Число(МассивЧастейДаты[4]);
			Секунда = Число(МассивЧастейДаты[5]);
			ДатаСобытия = Дата(Год,Месяц,День,Час,Минута,Секунда);
			
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат ДатаСобытия;
	
КонецФункции

&НаКлиенте
Процедура ПозиционироватьЧтениеНаСтрокуФайла(ЧтениеФайла, НомерСтроки)
	ТекНомерСтроки = 0;
	ТекСтрокаФайла = "";
	Пока ТекНомерСтроки < НомерСтроки 
		И ТекСтрокаФайла <> Неопределено Цикл
		ТекСтрокаФайла = ЧтениеФайла.ПрочитатьСтроку();
		ТекНомерСтроки = ТекНомерСтроки + 1;
	КонецЦикла; 
КонецПроцедуры

// Процедура - Создать динамические колонки таблицы
//
// Параметры:
//  ИмяТаблицы					 - строка	 - имя таблицы на форме строкой
//  МассивСтруктурКолонок		 - 	 - описание создаваемых колонок
//  МассивСтруктурТекущихКолонок - 	 - описание текущих колонок для удаления из текущей таблицы
&НаСервере
Процедура СоздатьДинамическиеКолонкиТаблицы(ИмяТаблицы,МассивСтруктурКолонок,МассивСтруктурТекущихКолонок)
	
	МассивУдаляемыхЭлементов = новый Массив;
	МассивДобавляемыхЭлементов = новый Массив;
	
	Для каждого Колонка из МассивСтруктурТекущихКолонок Цикл
		МассивУдаляемыхЭлементов.Добавить(ИмяТаблицы+"."+Колонка.Имя);
		Элементы.Удалить(Элементы[ИмяТаблицы+Колонка.Имя]);    
	КонецЦикла;   
	
	МассивТипов = новый Массив;
	МассивТипов.Добавить(Тип("ТаблицаЗначений"));           
	ОписаниеТиповТаблица = Новый ОписаниеТипов(МассивТипов);
	МассивТипов = новый Массив;
	МассивТипов.Добавить(Тип("Строка"));          
	ОписаниеТиповСтрока = Новый ОписаниеТипов(МассивТипов);
	
	Для каждого Колонка из МассивСтруктурКолонок Цикл
		Если Колонка.ТипЗначения = ОписаниеТиповТаблица Тогда
			ОписаниеТипов = ОписаниеТиповСтрока;
		Иначе
			ОписаниеТипов = новый ОписаниеТипов(Колонка.ТипЗначения);
		КонецЕсли;
		НовыйРеквизит = Новый РеквизитФормы(Колонка.Имя, ОписаниеТипов, ИмяТаблицы, Колонка.Имя, Ложь);
		МассивДобавляемыхЭлементов.Добавить(НовыйРеквизит);
	КонецЦикла;
	
	ЭтаФорма.ИзменитьРеквизиты(МассивДобавляемыхЭлементов,МассивУдаляемыхЭлементов);
	
	
	Для каждого Колонка из МассивСтруктурКолонок Цикл                       
		НовыйЭлемент = Элементы.Вставить(Элементы[ИмяТаблицы].Имя+Колонка.Имя, Тип("Полеформы"), Элементы[ИмяТаблицы]);
		НовыйЭлемент.Вид = ВидПоляФормы.ПолеВвода;
		НовыйЭлемент.Видимость = Истина;
		НовыйЭлемент.Доступность = Истина;
		НовыйЭлемент.ТолькоПросмотр = Ложь;   
		НовыйЭлемент.Высота = 0;
		НовыйЭлемент.Ширина = Колонка.Ширина;                
		НовыйЭлемент.Заголовок = Колонка.Заголовок;
		НовыйЭлемент.Подсказка = Колонка.Имя;
		НовыйЭлемент.ПутьКДанным = ИмяТаблицы+"."+Колонка.Имя;    
	КонецЦикла;
	
	
КонецПроцедуры         

&НаКлиенте
Процедура ЗагрузитьДанныеИзФайла(Команда)
	ТаблицаДанных.Очистить();
	РазобратьФайлВТаблицуCSV(ПутьКДанным);
	// обновим параметры выбора для данных
	ОбновитьПараметрыВыбораВходов();
КонецПроцедуры

&НаКлиенте
Функция СохранитьФайлВТаблицуCSV(ПутьКФайлу) Экспорт
	
	ИмяФайлаДляРазбора 	= ПутьКФайлу;  	
	
	ДатаНачалаЧтения = ТекущаяДата();
	
	Текст = Новый ЗаписьТекста(ИмяФайлаДляРазбора, КодировкаТекста.ANSI, Символы.ВК + Символы.ПС, Ложь,"");
	
	СтрокаТекста = "";
	// заголовки
	Для каждого колонка из КолонкиТаблицыДанных Цикл
		СтрокаТекста = СтрокаТекста + ?(СтрокаТекста="","",",")+""""+колонка.Заголовок+"""";
	КонецЦикла;
	Текст.ЗаписатьСтроку(СтрокаТекста,Символы.ВК + Символы.ПС);
	
	// данные
	Для каждого стр из ТаблицаДанных Цикл
		СтрокаТекста = "";
		Для каждого колонка из КолонкиТаблицыДанных Цикл
			СтрокаТекста = СтрокаТекста + ?(СтрокаТекста="","",",")+""""+XMLСтрока(стр[колонка.Имя])+"""";
		КонецЦикла;
		Текст.ЗаписатьСтроку(СтрокаТекста,Символы.ВК + Символы.ПС);
	КонецЦикла;
	
	Текст.Закрыть();
	
	Возврат 0;
КонецФункции


&НаКлиенте
Процедура СохранитьДанныеВФайл(Команда)
	// сохраним в CSV
	СохранитьФайлВТаблицуCSV(ПутьКДанным);	
КонецПроцедуры


#КонецОбласти

#Область ОторбразитьНаГрафикеДанные

&НаКлиенте
Процедура ОбновитьПараметрыВыбораВходов()
	
	Элементы.ВходыСигнал.СписокВыбора.Очистить();
	Элементы.РедактируемыйВход.СписокВыбора.Очистить();
	Для  каждого стр из КолонкиТаблицыДанных Цикл
		Элементы.ВходыСигнал.СписокВыбора.Добавить(стр.Имя,стр.Заголовок);
		Элементы.РедактируемыйВход.СписокВыбора.Добавить(стр.Имя,стр.Заголовок);
	КонецЦикла;
	
	РедактируемыйВход = "Процессор(_Total)\% загруженности процессора";
	
КонецПроцедуры

&НаСервере
Процедура ОтобразитьНаГрафикеВходыНаСервере()
	
	ЭпохОбучения = 0;
	ТаблицаСвязей.Очистить();
	
	НаборТочек = Новый Массив;
	МассивКластера = новый Массив;
	
	// Если тип значение дата, тогда надо привести к относительному значению
	
	Для каждого стр из ТаблицаДанных Цикл
		
		Вход0 = Входы[0].Сигнал;
		Вход1 = Входы[1].Сигнал;
		МассивКластера.Добавить(новый Структура("x,y",стр[Вход0],стр[Вход1]));
		
	КонецЦикла;
	
	НаборТочек.Добавить(МассивКластера);
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	Данные.НаборТочек = НаборТочек;
	Данные.НейроннаяСетьКохонена = Неопределено;
	ХранилищеОбщихНастроек.Сохранить("НейроннаяСетьКохонена",,Данные);
	
	
КонецПроцедуры

&НаКлиенте
Процедура ОтобразитьНаГрафикеВходы(Команда)
	ОтобразитьНаГрафикеВходыНаСервере();
КонецПроцедуры


#КонецОбласти

#Область РисуемГрафик

&НаКлиенте
Процедура СоздатьСвойстваКнопок()
	
	МассивКнопок = ПолучитьМассивИменКнопок();
	МассивСинонимовСвойств = ПолучитьМассивСинонимовСвойств();
	
	Для каждого кнопка из МассивКнопок Цикл
		Для каждого синоним из МассивСинонимовСвойств Цикл
			стр_н= СвойстваКнопокРедактирования.Добавить();
			стр_н.Кнопка = кнопка;
			стр_н.Синоним = синоним;
			Если синоним="t шаг" Тогда
				стр_н.Значение = 15;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	НажатаяКнопкаРедактирования = "Неопределено";
	УстановитьФильтрСвойствТаблицыРедактирования();
	РежимРедактированияГрафика = "Добавление";
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьМассивСинонимовСвойств()
	
	ТекстыСвойств = "t нач.
	|t кон.
	|h нач.
	|h кон.
	|t шаг
	|k";
	МассивКнопок = СтрРазделить(ТекстыСвойств,Символы.ПС,Ложь);
	Возврат МассивКнопок;
	
КонецФункции

&НаКлиенте
Функция ПолучитьМассивИменКнопок()
	
	ТекстыКнопок = "ЛинейныйВозрастающий ЛинейныйУбывающий БелыйШум Фильтр 
	| СтупенькаВверх СтупенькаВниз НелинейноВозрастающий НелинейноУбывающий 
	| СкачокВверх СкачокВниз ПоднятьВверх ОпуститьВниз 
	| Линия Очистить ";
	ТекстыКнопок = СтрЗаменить(ТекстыКнопок,Символы.ПС,"");
	МассивКнопок = СтрРазделить(ТекстыКнопок," ",Ложь);
	Возврат МассивКнопок;
	
КонецФункции	

&НаКлиенте
Процедура НажатиеКнопкиРисунка(Элемент)
	
	МассивКнопок = ПолучитьМассивИменКнопок();
	ТипНажата = ТипРамкиЭлементаУправления.Вдавленная;
	ТипОжидание = ТипРамкиЭлементаУправления.Выпуклая;
	
	
	Для каждого стр из МассивКнопок Цикл
		Элементы[стр].Рамка  = новый Рамка(ТипОжидание,2);
	КонецЦикла;
	
	Элемент.Рамка =  новый Рамка(ТипНажата,2);
	НажатаяКнопкаРедактирования = Элемент.Имя;
	
	УстановитьФильтрСвойствТаблицыРедактирования();
	
	
КонецПроцедуры

&НаКлиенте
Процедура УстановитьФильтрСвойствТаблицыРедактирования()
	
	// фильтр
	СтруктураОтбора = новый Структура("Кнопка",НажатаяКнопкаРедактирования);
	ФиксОтбор = новый ФиксированнаяСтруктура(СтруктураОтбора);		
	
	Элементы.СвойстваКнопокРедактирования.ОтборСтрок = ФиксОтбор;
	
КонецПроцедуры

&НаКлиенте
Процедура ПрименитьИзмененияРисунка(Команда)
	
	ОбработатьНажатуюКнопкуРедактора();	
	ПерерисоватьГрафикТочекHTML();
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьНажатуюКнопкуРедактора()
	
	Кнопка = НажатаяКнопкаРедактирования;
	
	t_нач = ПолучитьЗначениеСвойства(Кнопка,"t нач.");
	t_кон = ПолучитьЗначениеСвойства(Кнопка,"t кон.");
	h_нач = ПолучитьЗначениеСвойства(Кнопка,"h нач.");
	h_кон = ПолучитьЗначениеСвойства(Кнопка,"h кон.");
	k = ПолучитьЗначениеСвойства(Кнопка,"k");
	
	ШиринаОкна = t_кон - t_нач;
	ШагВремени = ПолучитьЗначениеСвойства(Кнопка,"t шаг");
	
	// получим имя свойства
	Свойство = НайтиИмяВходаТаблицыДанных(РедактируемыйВход);
	
	
	Если Кнопка = "Линия" Тогда
		
		Если ШагВремени<=0  Тогда
			Сообщить("Установите шаг времени!");
			Возврат;
		КонецЕсли;
		
		ш = t_нач;
		Пока ш<=t_кон Цикл  
			
			стр_н = НайтиСоздатьТочкуТаблицы("ТаблицаДанных",ш);
			стр_н.ВремяЧислом = ш;
			стр_н[Свойство] = h_нач;
			ш=ш+ШагВремени;			
			
		КонецЦикла;
		
		
		// Очищаем в 0 в интервале
	ИначеЕсли НажатаяКнопкаРедактирования = "Очистить" Тогда		
		
		
		Для каждого стр из ТаблицаДанных Цикл
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			стр[Свойство] = 0;
			
		КонецЦикла;		
		
	ИначеЕсли НажатаяКнопкаРедактирования="ЛинейныйВозрастающий" 
		ИЛИ НажатаяКнопкаРедактирования="ЛинейныйУбывающий"  Тогда
		
		Если ШагВремени<=0  Тогда
			Сообщить("Установите шаг времени!");
			Возврат;
		КонецЕсли;
		
		alpa = (h_кон-h_нач)/(t_кон-t_нач);
		beta = h_нач - t_нач*alpa;
		
		ш = t_нач;
		Пока ш<=t_кон Цикл  
			
			стр_н = НайтиСоздатьТочкуТаблицы("ТаблицаДанных",ш);
			стр_н.ВремяЧислом = ш;
			Если РежимРедактированияГрафика="Замена" Тогда
				стр_н[Свойство] = alpa*ш+beta;
			Иначе
				стр_н[Свойство] = стр_н[Свойство]+alpa*ш+beta;
			КонецЕсли;
			ш=ш+ШагВремени;			
			
		КонецЦикла;
		
	ИначеЕсли НажатаяКнопкаРедактирования="БелыйШум" Тогда
		
		Если ШагВремени<=0  Тогда
			Сообщить("Установите шаг времени!");
			Возврат;
		КонецЕсли;
		
		
		ГСЧ = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
		
		ш = t_нач;
		Пока ш<=t_кон Цикл  
			
			Значение = ГСЧ.СлучайноеЧисло(h_нач*1000,h_кон*1000)/1000;
			
			стр_н = НайтиСоздатьТочкуТаблицы("ТаблицаДанных",ш);
			стр_н.ВремяЧислом = ш;
			Если РежимРедактированияГрафика="Замена" Тогда
				стр_н[Свойство] = Значение;
			Иначе
				стр_н[Свойство] = стр_н[Свойство]+Значение;
			КонецЕсли;
			ш=ш+ШагВремени;			
			
		КонецЦикла;
		
		// Усредним
	ИначеЕсли НажатаяКнопкаРедактирования="Фильтр" Тогда
		
		стр = Неопределено;
		стр1 = Неопределено;
		
		Для ш=0 по ТаблицаДанных.Количество()-1 Цикл
			стр = ТаблицаДанных[ш];
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			Если стр1=Неопределено Тогда
				стр1 = стр[Свойство];
			Иначе
				стр1 = ТаблицаДанных[ш-1];
				стр1[Свойство] = (стр1[Свойство]+стр[Свойство])/2;
			КонецЕсли;			
			
		КонецЦикла;
		
		// последняя точка
		Если ТаблицаДанных.Количество()>1 Тогда
			стр[Свойство]=(стр1[Свойство]+стр[Свойство])/2;
		КонецЕсли;
		// поднимим опустим
	ИначеЕсли НажатаяКнопкаРедактирования="ПоднятьВверх" ИЛИ 
		НажатаяКнопкаРедактирования="ОпуститьВниз" Тогда
		
		Для каждого стр из ТаблицаДанных Цикл
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			Если НажатаяКнопкаРедактирования="ПоднятьВверх" Тогда
				стр[Свойство] = стр[Свойство]+h_нач;
			Иначе
				стр[Свойство] = стр[Свойство]-h_нач;
			КонецЕсли;			
			
		КонецЦикла;	
		
	ИначеЕсли НажатаяКнопкаРедактирования="СкачокВверх" ИЛИ 
		НажатаяКнопкаРедактирования="СкачокВниз" Тогда
		
		Для каждого стр из ТаблицаДанных Цикл
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			Если НажатаяКнопкаРедактирования="СкачокВверх" Тогда
				стр[Свойство] = стр[Свойство]+h_нач;
			Иначе
				стр[Свойство] = стр[Свойство]-h_нач;
			КонецЕсли;
			
			Прервать;
			
		КонецЦикла;	
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция НайтиСоздатьТочкуТаблицы(ИмяТаблицы,ВремяЧислом,СоздаватьНовый=Истина)
	
	мОтбор = новый Структура("ВремяЧислом",ВремяЧислом);
	н_строки = ЭтаФорма[ИмяТаблицы].НайтиСтроки(мОтбор);
	
	Если н_строки.Количество()=0 Тогда
		Если СоздаватьНовый=Ложь Тогда
			Возврат Неопределено;
		КонецЕсли;
		стр_н =  ЭтаФорма[ИмяТаблицы].Добавить();
		// обнулим
		Для каждого стр из КолонкиТаблицыДанных Цикл
			Если стр_н[стр.Имя]=Неопределено Тогда
				стр_н[стр.Имя] = 0;
			КонецЕсли;
		КонецЦикла;
		Возврат стр_н;
	Иначе
		Возврат н_строки[0];
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция НайтиИмяВходаТаблицыДанных(Заголовок)
	Свойство = "";
	
	Если КолонкиТаблицыДанных=НЕопределено Тогда
		Возврат Свойство;
	КонецЕсли;
	
	Для каждого стр из КолонкиТаблицыДанных Цикл
		
		Если Заголовок=стр.Имя Тогда
			Свойство = Заголовок;
			Прервать;
		КонецЕсли;
		
		Если Заголовок=стр.Заголовок Тогда
			Свойство = стр.Имя;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Свойство;
КонецФункции	

&НаСервере
Функция НайтиИмяЗаголовкаТаблицыДанных(Свойство)
	Заголовок = "";
	
	Если КолонкиТаблицыДанных=НЕопределено Тогда
		Возврат Заголовок;
	КонецЕсли;
	
	Для каждого стр из КолонкиТаблицыДанных Цикл
		
		Если Свойство=стр.Имя Тогда
			Заголовок = стр.Заголовок;
			Прервать;
		КонецЕсли;
		
		Если Свойство=стр.Заголовок Тогда
			Заголовок = Свойство;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Заголовок;
КонецФункции	

&НаКлиенте
Функция ПолучитьЗначениеСвойства(Кнопка,Синоним)
	
	мОтбор = новый Структура("Кнопка,Синоним",Кнопка,Синоним);
	н_строки = СвойстваКнопокРедактирования.НайтиСтроки(мОтбор);
	
	Возврат н_строки[0].Значение;
	
КонецФункции

&НаКлиенте
Процедура УстановитьЗначениеСвойства(Кнопка,Синоним,Значение)
	
	мОтбор = новый Структура("Кнопка,Синоним",Кнопка,Синоним);
	н_строки = СвойстваКнопокРедактирования.НайтиСтроки(мОтбор);
	
	н_строки[0].Значение = Значение;
	
КонецПроцедуры


&НаКлиенте
Процедура ПерерисоватьГрафикТочекHTML()
	
	
	ПолеChart = Элементы.ГрафикHTML.Документ.getElementById("myDiv");
	
	Если ПолеChart=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ИмяВхода0 = "ВремяЧислом";
	ИмяВхода1 = НайтиИмяВходаТаблицыДанных(РедактируемыйВход); 
	
	array = "
	|var points = {
	|mode: 'lines',
	|type: 'scatter',
	|name: 'Points',
	|marker: { size: 8 },";
	
	
	// точки
	x_str = "";
	y_str = "";
	
	
	Для каждого стр из ТаблицаДанных Цикл
		x_str = x_str +?(x_str="","",",")+ XMLСтрока(стр[ИмяВхода0]);
		y_str = y_str +?(y_str="","",",")+ XMLСтрока(стр[ИмяВхода1]);		
	КонецЦикла;
	
	array = array+"
	|x: ["+x_str+"],
	|y: ["+y_str+"]";
	array = array+"
	|};";
	
	
	array = array+ "
	|var som = {
	|mode: 'markers',
	|type: 'scatter',
	|name: 'Clusters',
	|marker: { size: 12 },
	|x: [0],
	|y: [0]
	|};";
	
	
	
	JS=array+"var data = [ points, som ];";	
	
	
	delement = Элементы.ГрафикHTML.Документ.getElementById("d");
	delement.value = JS;
	
	element = Элементы.ГрафикHTML.Документ.getElementById("t");
	element.onClick();	
	
	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьГрафикРедактора(Команда)
	ПерерисоватьГрафикТочекHTML();
КонецПроцедуры



#КонецОбласти


#Область Моделирование


&НаКлиенте
Процедура Play(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры

&НаКлиенте
Процедура Stop(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры

&НаКлиенте
Процедура Pause(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры

&НаКлиенте
Процедура StepNext(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры

&НаКлиенте
Процедура StepBack(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры


#КонецОбласти

#Область Проект

&НаКлиенте
Процедура ПутьКПроектуНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие); 
	Диалог.Заголовок = "Выберите файл"; 
	Если ЗначениеЗаполнено(ПутьКПроекту) Тогда
		Диалог.Каталог = ПолучитьКаталогПоПутиФайла(ПутьКПроекту);
	КонецЕсли;
	Диалог.ПолноеИмяФайла = ""; 
	Фильтр = "XML-файл (*.xml)|*.xml"; 
	Диалог.Фильтр = Фильтр; 
	Диалог.МножественныйВыбор = Ложь; 
	ВыборФайлаОткрытияФайла = новый ОписаниеОповещения("ВыборФайлаОткрытияФайла",ЭтотОбъект,новый Структура("ИмяРеквизита","ПутьКПроекту"));
	Диалог.Показать(ВыборФайлаОткрытияФайла);
КонецПроцедуры



&НаКлиенте
Процедура СохранитьПроект(Команда)
	
	ТекстоваяСтрокаФайла = ВыгрузитьПроектВXML();
	
	Документ = новый ТекстовыйДокумент;
	Документ.УстановитьТекст(ТекстоваяСтрокаФайла);
	СохранениеФайлаПроекта = новый ОписаниеОповещения("СохранениеФайлаПроекта",ЭтотОбъект);
	Документ.НачатьЗапись(СохранениеФайлаПроекта,ПутьКПроекту,"UTF-8");

КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьПроект(Команда)
	ЗагрузитьПроектXML(ПутьКПроекту);
КонецПроцедуры


&НаКлиенте
Процедура СохранениеФайлаПроекта(Результат, ДополнительныеПараметры) Экспорт
	
	Если Результат=Истина Тогда
		Сообщить("Файл записан успешно!");
	Иначе
		Сообщить("При сохранении файла произошла ошибка!");	
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Функция ВыгрузитьПроектВXML()
	
	XMLСтрока = ""; 
	
	Данные = ХранилищеОбщихНастроек.Загрузить("НейроннаяСетьКохонена");
	НаборТочек = Данные.НаборТочек;
	НейроннаяСетьКохонена = Данные.НейроннаяСетьКохонена;
	
	Попытка
		
		// Создать объект записи XML и открыть файл
		НоваяЗаписьXML = Новый ЗаписьXML;
		НоваяЗаписьXML.УстановитьСтроку("UTF-8");
		
		НоваяЗаписьXML.ЗаписатьОбъявлениеXML();
		
		НоваяЗаписьXML.ЗаписатьНачалоЭлемента("project");
		
			НоваяЗаписьXML.ЗаписатьАтрибут("verion","1.0");
			НоваяЗаписьXML.ЗаписатьАтрибут("author","ivanov660");
			НоваяЗаписьXML.ЗаписатьАтрибут("url","https://github.com/Polyplastic/1c-parsing-tech-log/issues");
			
			// Нейронная сеть
			НоваяЗаписьXML.ЗаписатьНачалоЭлемента("neuralnetwork");
			
				//НоваяЗаписьXML.ЗаписатьАтрибут("inputs","2");
				//НоваяЗаписьXML.ЗаписатьАтрибут("neurons","2");
				
				НоваяЗаписьXML.ЗаписатьНачалоЭлемента("inputs");
				Для каждого вход из НейроннаяСетьКохонена._inputs Цикл
					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("input");
					НоваяЗаписьXML.ЗаписатьАтрибут("id",		XMLСтрока(вход.Id));
					Для каждого связь из вход.OutgoingLinks Цикл
						НоваяЗаписьXML.ЗаписатьНачалоЭлемента("link");
						НоваяЗаписьXML.ЗаписатьАтрибут("id",		XMLСтрока(связь));
						НоваяЗаписьXML.ЗаписатьКонецЭлемента();
					КонецЦикла;
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();	
				КонецЦикла;
				НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				
				// Связи
				НоваяЗаписьXML.ЗаписатьНачалоЭлемента("links");
				
				Для каждого кл_связь из НейроннаяСетьКохонена._links Цикл
					
					связь = кл_связь.Значение;
					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("link");
					НоваяЗаписьXML.ЗаписатьАтрибут("id",	XMLСтрока(кл_связь.Ключ));
					НоваяЗаписьXML.ЗаписатьАтрибут("weight",		XMLСтрока(связь.Weight));
					НоваяЗаписьXML.ЗаписатьАтрибут("startweight",	XMLСтрока(связь.StartWeight));
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();
					
				КонецЦикла;
				
				НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				
				// Нейроны
				НоваяЗаписьXML.ЗаписатьНачалоЭлемента("neurons");
				
				Для каждого нейрон из НейроннаяСетьКохонена._neurons Цикл
					
					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("neuron");
					НоваяЗаписьXML.ЗаписатьАтрибут("cluster",	XMLСтрока(нейрон.Cluster));
					НоваяЗаписьXML.ЗаписатьАтрибут("power",		XMLСтрока(нейрон.Power));
					НоваяЗаписьXML.ЗаписатьАтрибут("id",		XMLСтрока(нейрон.Id));
					НоваяЗаписьXML.ЗаписатьАтрибут("wins",		XMLСтрока(нейрон.Wins));
					НоваяЗаписьXML.ЗаписатьАтрибут("func",		XMLСтрока(нейрон.func));
					Для каждого связь из нейрон.IncomingLinks Цикл
						НоваяЗаписьXML.ЗаписатьНачалоЭлемента("link");
						НоваяЗаписьXML.ЗаписатьАтрибут("id",		XMLСтрока(связь));
						НоваяЗаписьXML.ЗаписатьКонецЭлемента();
					КонецЦикла;
					
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();
					
				КонецЦикла;				
		
				НоваяЗаписьXML.ЗаписатьКонецЭлемента();
			
			НоваяЗаписьXML.ЗаписатьКонецЭлемента();
			
			// связь входов модели
			НоваяЗаписьXML.ЗаписатьНачалоЭлемента("object");
			
				НоваяЗаписьXML.ЗаписатьНачалоЭлемента("inputs");
				Для каждого стр из КолонкиТаблицыДанных Цикл
					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("input");
					НоваяЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока(стр.Заголовок));
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				КонецЦикла;
				НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				
				НоваяЗаписьXML.ЗаписатьНачалоЭлемента("inputlinks");
				Для каждого стр из Входы Цикл
					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("link");
					НоваяЗаписьXML.ЗаписатьАтрибут("idinput", XMLСтрока(стр.Id));
					НоваяЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока(НайтиИмяЗаголовкаТаблицыДанных(стр.Сигнал)));
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				КонецЦикла;
				НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				
			
			НоваяЗаписьXML.ЗаписатьКонецЭлемента();
		
		
		// Конец основного тега
		НоваяЗаписьXML.ЗаписатьКонецЭлемента();         
		XMLСтрока = НоваяЗаписьXML.Закрыть();
		
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Сообщить(ТекстОшибки);
	КонецПопытки;

	Возврат XMLСтрока;
	
КонецФункции


&НаКлиенте
Функция ЗагрузитьПроектXML(ПутьКФайлу)
	
	
	Входы.Очистить();
	НейроннаяСеть = новый Структура("_inputs,_links,_neurons",новый Массив,новый Массив, новый Массив);
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	
	Попытка
		ЧтениеXML.ОткрытьФайл(сокрЛП(ПутьКфайлу));
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.Имя = "neuralnetwork" Тогда
			Пока ЧтениеXML.Прочитать() Цикл
				Если ЧтениеXML.Имя = "neuralnetwork" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
					Прервать;
				ИначеЕсли ЧтениеXML.Имя = "inputs" Тогда
					вход = Неопределено;
					Пока ЧтениеXML.Прочитать() Цикл
						Если ЧтениеXML.Имя = "inputs" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Прервать;
						ИначеЕсли ЧтениеXML.Имя = "input" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
								НейроннаяСеть._inputs.Добавить(вход);
						ИначеЕсли  ЧтениеXML.Имя="input" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента  Тогда
							вход  = новый Структура("id,OutgoingLinks",0,новый Массив);
							вход.Id=Число(ЧтениеXML.ПолучитьАтрибут("id"));
						ИначеЕсли  ЧтениеXML.Имя="link" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента  Тогда
							link = ЧтениеXML.ПолучитьАтрибут("id");
							вход.OutgoingLinks.Добавить(link);
						КонецЕсли;
					КонецЦикла;
				ИначеЕсли ЧтениеXML.Имя = "links" Тогда
					связь = Неопределено;
					Пока ЧтениеXML.Прочитать() Цикл
						Если ЧтениеXML.Имя = "links" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Прервать;
						ИначеЕсли ЧтениеXML.Имя = "link" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							НейроннаяСеть._links.Добавить(связь);
						ИначеЕсли  ЧтениеXML.Имя="link" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента  Тогда
							связь = новый Структура("id,weight,startweight",0,0,0);
							связь.id = ЧтениеXML.ПолучитьАтрибут("id");
							связь.weight = Число(ЧтениеXML.ПолучитьАтрибут("weight"));
							связь.startweight = Число(ЧтениеXML.ПолучитьАтрибут("startweight"));
						КонецЕсли;
					КонецЦикла;
				ИначеЕсли ЧтениеXML.Имя = "neurons" Тогда 					
					нейрон = Неопределено;
					Пока ЧтениеXML.Прочитать() Цикл
						Если ЧтениеXML.Имя = "neurons" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Прервать;
						ИначеЕсли ЧтениеXML.Имя = "neuron" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
								НейроннаяСеть._neurons.Добавить(нейрон);
						ИначеЕсли  ЧтениеXML.Имя="neuron" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента  Тогда
							нейрон  = новый Структура("id,IncomingLinks,cluster,wins,power,func",0,новый Массив,"",0,0,"");
							нейрон.Id=Число(ЧтениеXML.ПолучитьАтрибут("id"));
							нейрон.cluster=ЧтениеXML.ПолучитьАтрибут("cluster");
							нейрон.power=Число(ЧтениеXML.ПолучитьАтрибут("power"));
							нейрон.wins=Число(ЧтениеXML.ПолучитьАтрибут("wins"));
							нейрон.func=ЧтениеXML.ПолучитьАтрибут("func");
						ИначеЕсли  ЧтениеXML.Имя="link" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента  Тогда
							link = ЧтениеXML.ПолучитьАтрибут("id");
							нейрон.IncomingLinks.Добавить(link);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ЧтениеXML.Имя = "object" Тогда
			Пока ЧтениеXML.Прочитать() Цикл
				Если ЧтениеXML.Имя = "object" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
					Прервать;
				ИначеЕсли ЧтениеXML.Имя = "inputs" Тогда
				ИначеЕсли ЧтениеXML.Имя = "inputlinks" Тогда
					Пока ЧтениеXML.Прочитать() Цикл
						Если ЧтениеXML.Имя = "inputlinks" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Прервать;
						ИначеЕсли  ЧтениеXML.Имя="link" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента  Тогда
							стр_н = Входы.Добавить();
							стр_н.Id=ЧтениеXML.ПолучитьАтрибут("idinput");
							стр_н.Сигнал=ЧтениеXML.ПолучитьАтрибут("name");
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

&НаКлиенте
Процедура ГенерироватьТаблицу(Команда)
	ш=0;
	ж=0;
	Если ШиринаОкна<0 Тогда
		ШиринаОкна=-ШиринаОкна;
	КонецЕсли;
	Если ШагОкна<0 Тогда
		ШагОкна=-ШагОкна;
	КонецЕсли;
	Пока ш<ШиринаОкна Цикл
		
		стр_н = ТаблицаДанных.Добавить();
		стр_н.НомерСтроки = ж;
		стр_н.ВремяЧислом = ш;
		Для каждого стр Из КолонкиТаблицыДанных Цикл
			стр_н[стр.Имя] = 0;
		КонецЦикла;		
	
		ш=ш+ШагОкна;
		ж=ж+1;
	КонецЦикла;
КонецПроцедуры

#КонецОбласти