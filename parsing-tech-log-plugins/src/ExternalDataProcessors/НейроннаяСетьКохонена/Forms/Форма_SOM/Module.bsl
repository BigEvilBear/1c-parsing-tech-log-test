&НаКлиенте
Перем СтарыеКолонки;
&НаКлиенте
Перем СтарыеКолонкиТаблицаКохонена;
&Наклиенте
Перем НейроннаяСетьКартаКохонена;
&Наклиенте
Перем КешВычисленийНейроннаяСеть;
&НаКлиенте
Перем КешПараметров;

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	//Элементы.СтраницаSOM.ЦветФона= Новый Цвет(170, 207, 219);
КонецПроцедуры


// Процедура - Создать динамические колонки таблицы
//
// Параметры:
//  ИмяТаблицы					 - строка	 - имя таблицы на форме строкой
//  МассивСтруктурКолонок		 - 	 - описание создаваемых колонок
//  МассивСтруктурТекущихКолонок - 	 - описание текущих колонок для удаления из текущей таблицы
&НаСервере
Процедура СоздатьДинамическиеКолонкиТаблицы(ИмяТаблицы,МассивСтруктурКолонок,МассивСтруктурТекущихКолонок,КромеИменКолонок="")
	
	МассивУдаляемыхЭлементов = Новый Массив;
	МассивДобавляемыхЭлементов = Новый Массив;
	
	Для каждого Колонка из МассивСтруктурТекущихКолонок Цикл
		Если Найти(КромеИменКолонок,Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		МассивУдаляемыхЭлементов.Добавить(ИмяТаблицы+"."+Колонка.Имя);
		Элементы.Удалить(Элементы[ИмяТаблицы+Колонка.Имя]);    
	КонецЦикла;   
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("ТаблицаЗначений"));           
	ОписаниеТиповТаблица = Новый ОписаниеТипов(МассивТипов);
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("Строка"));          
	ОписаниеТиповСтрока = Новый ОписаниеТипов(МассивТипов);
	
	Для каждого Колонка из МассивСтруктурКолонок Цикл
		Если Найти(КромеИменКолонок,Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		Если Колонка.ТипЗначения = ОписаниеТиповТаблица Тогда
			ОписаниеТипов = ОписаниеТиповСтрока;
		Иначе
			ОписаниеТипов = Новый ОписаниеТипов(Колонка.ТипЗначения);
		КонецЕсли;
		НовыйРеквизит = Новый РеквизитФормы(Колонка.Имя, ОписаниеТипов, ИмяТаблицы, Колонка.Имя, Ложь);
		МассивДобавляемыхЭлементов.Добавить(НовыйРеквизит);
	КонецЦикла;
	
	Если МассивДобавляемыхЭлементов.Количество()=0 И МассивУдаляемыхЭлементов.Количество()=0 Тогда
		Возврат;
	КонецЕсли;
	
	ЭтаФорма.ИзменитьРеквизиты(МассивДобавляемыхЭлементов,МассивУдаляемыхЭлементов);
	
	Для каждого Колонка из МассивСтруктурКолонок Цикл                       
		Если Найти(КромеИменКолонок,Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли;
		СледующийЭлемент = Неопределено;
		Если НЕ Колонка.ИмяСледующегоЭлемента=Неопределено Тогда
			СледующийЭлемент = Элементы.Найти(Колонка.ИмяСледующегоЭлемента);
		КонецЕсли;
		НовыйЭлемент = Элементы.Вставить(Элементы[ИмяТаблицы].Имя+Колонка.Имя, Тип("Полеформы"), Элементы[ИмяТаблицы],СледующийЭлемент);
		Если Колонка.ТипСтрокой="Булево" Или  Колонка.ТипСтрокой="Boolean"Тогда
			НовыйЭлемент.Вид = ВидПоляФормы.ПолеФлажка;
		Иначе
			НовыйЭлемент.Вид = ВидПоляФормы.ПолеВвода;
			НовыйЭлемент.Высота = 0;
			НовыйЭлемент.Ширина = Колонка.Ширина;                
		КонецЕсли;
		НовыйЭлемент.Видимость = Колонка.Видимость;
		НовыйЭлемент.Доступность = Истина;
		НовыйЭлемент.ТолькоПросмотр = Колонка.ТолькоПросмотр;   
		НовыйЭлемент.Заголовок = Колонка.Заголовок;
		НовыйЭлемент.Подсказка = Колонка.Заголовок;
		НовыйЭлемент.ПутьКДанным = ИмяТаблицы+"."+Колонка.Имя;    
	КонецЦикла;
	
	
КонецПроцедуры     

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	//Модуль_ВекторноеПространство = ПолучитьФорму("ВнешняяОбработка.МенеджерСценарногоТеста.Форма.Модуль_ВекторноеПространство");
	
	СтарыеКолонки = Новый Массив;
	СтарыеКолонкиТаблицаКохонена = Новый Массив;
	Элементы.ОтображениеСетки.СписокВыбора.Добавить("ничего");
	Элементы.ОтображениеСетки.СписокВыбора.Добавить("все");
	Элементы.ОтображениеСетки.СписокВыбора.Добавить("победы");
	Элементы.ОтображениеСетки.СписокВыбора.Добавить("кластер");
	Элементы.ОтображениеСетки.СписокВыбора.Добавить("доминатор");
	Если НЕ ЗначениеЗаполнено(ОтображениеСетки) Тогда
		ОтображениеСетки="победы";
	КонецЕсли;
	Элементы.МераОценки.СписокВыбора.Добавить("дистанция");
	Элементы.МераОценки.СписокВыбора.Добавить("косинус");
	Если НЕ ЗначениеЗаполнено(МераОценки) Тогда
		МераОценки = "дистанция";
	КонецЕсли;  
	
	Если ВысотаСети=0 Тогда
		ВысотаСети=2;
	КонецЕсли;
	
	Если ШиринаСети=0 Тогда
		ШиринаСети=2;
	КонецЕсли;
	
	ТестСетиПриИзменении(Неопределено);
	ОбновитьПараметрыВыбораВходов();
	СоздатьСвойстваКнопок();
	
	ИмяКолонкиДатаВремя = "ДатаВремя";
	
	ДиаграммаРедактора.РежимРедактированияЗначений=РежимРедактированияЗначенийДиаграммы.Использовать;
	
	Если НЕ ЗначениеЗаполнено(МодификацииАлгоритма) Тогда
		МодификацииАлгоритма="SOM";
	КонецЕсли;
	
	Элементы.МодификацииАлгоритма.СписокВыбора.Добавить("SOM","Self-Organizing Maps");
	Элементы.МодификацииАлгоритма.СписокВыбора.Добавить("GNG","Growing Neural Gas");
	Элементы.МодификацииАлгоритма.СписокВыбора.Добавить("ForgetOldWins","Forget Old Wins");
	
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(300,"5 мин");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(600,"10 мин");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(1200,"20 мин");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(1800,"30 мин");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(3600,"1 ч");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(5400,"1 ч 30 мин");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(7200,"2 ч");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(10800,"3 ч");
	//Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(14400,"4 ч");
	//Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(18000,"5 ч");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(21000,"6 ч");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(43200,"12 ч");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(86400,"24 ч");
	Элементы.ГотовыеВариантыИнтервалИзБазы.СписокВыбора.Добавить(0,"произвольный");
	
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(-3600,"<1 ч");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(-1800,"<30 мин");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(-600,"<10 мин");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(-300,"<5 мин");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(0,"0");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(300,"5 мин>");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(600,"10 мин>");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(1800,"30 мин>");
	Элементы.БыстрыйСкроллОкна.СписокВыбора.Добавить(3600,"1 ч>");
	
	Элементы.НавигацияПоВремени.СписокВыбора.Добавить(-3,"< 3 шага");
	Элементы.НавигацияПоВремени.СписокВыбора.Добавить(-2,"< 2 шага");
	Элементы.НавигацияПоВремени.СписокВыбора.Добавить(-1,"< шаг");
	Элементы.НавигацияПоВремени.СписокВыбора.Добавить(0,"0");
	Элементы.НавигацияПоВремени.СписокВыбора.Добавить(1,"шаг >");
	Элементы.НавигацияПоВремени.СписокВыбора.Добавить(2,"2 шага >");
	Элементы.НавигацияПоВремени.СписокВыбора.Добавить(3,"3 шага >");
	
	Элементы.НаложитьМодельНаГрафикИзБазы.СписокВыбора.Добавить("НеИспользовать","не использовать");
	Элементы.НаложитьМодельНаГрафикИзБазы.СписокВыбора.Добавить("ТолькоАварии","аварии");
	Элементы.НаложитьМодельНаГрафикИзБазы.СписокВыбора.Добавить("ТолькоАномалии","аномалии");
	Элементы.НаложитьМодельНаГрафикИзБазы.СписокВыбора.Добавить("Все","все");
	
	Если НЕ ЗначениеЗаполнено(НаложитьМодельНаГрафикИзБазы) Тогда
		НаложитьМодельНаГрафикИзБазы = "НеИспользовать";
	КонецЕсли;
	
	Если НавигацияДлинаХвоста=0 Тогда
		НавигацияДлинаХвоста=3;
	КонецЕсли;
	
	ОбновитьСписокВыбораКластераИзБазы("КластерИзБазы");
	
	ОбновитьВидимость();
	
	КешПараметров = новый Соответствие;
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьМассивДанных(МассивДанных)
	
	ТаблицаАнализа.Очистить();
	
	шаг=0;
	Для каждого стр из МассивДанных Цикл

		стр_н = ТаблицаАнализа.Добавить();
		
		стр_н.НомерШага = шаг+1;
		
		ВходнойВектор = стр.ВходнойВектор;
		
		Результат = ОбработатьСетьюКохонена(ВходнойВектор,НейроннаяСетьКартаКохонена);
		
		стр_н.Оценка = Результат.Дистанция;
		стр_н.Кластер = Результат.Кластер;
	КонецЦикла;	
	
КонецПроцедуры

&НаКлиенте
Функция ОчиститьТекстОтплохихСимволов(Текст)
	
	ТекстРезультат = Текст;
	
	ТекстРезультат = СтрЗаменить(ТекстРезультат,":"," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,"&"," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,"*"," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,"."," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,"("," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,")"," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,""""," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,"'"," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,"\"," ");
	ТекстРезультат = СтрЗаменить(ТекстРезультат,"/"," ");
	
	Массив = СтрРазделить(ТекстРезультат," ",Ложь);
	ТекстРезультат = СтрСоединить(Массив," ");
	
	Возврат ТекстРезультат;
	
КонецФункции


#Область Кохонен

&НаКлиенте
Процедура ИнициализироватьКартуКохонена(КартаКохонена,ЧислоВходов,Высота,Ширина)
	
	КешВычисленийНейроннаяСеть = Новый Структура();
	КешВычисленийНейроннаяСеть.Вставить("КешЛитеральнойДистанции",Новый Соответствие);
	
	ГСЧ = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	
	КартаКохонена = Новый Структура();
	КартаКохонена.Вставить("Версия","1.0");
	КартаКохонена.Вставить("Автор","");
	КартаКохонена.Вставить("Описание","");
	КартаКохонена.Вставить("url","https://github.com/Polyplastic/1c-parsing-tech-log");
	КартаКохонена.Вставить("Тип","som");
	КартаКохонена.Вставить("ЧислоВходов",ЧислоВходов);
	КартаКохонена.Вставить("Высота",Высота);
	КартаКохонена.Вставить("Ширина",Ширина);
	КартаКохонена.Вставить("ЧислоНейронов",Высота*Ширина);
	КартаКохонена.Вставить("Нейроны",Новый Массив(Высота,Ширина));
	КартаКохонена.Вставить("Входы",Новый Массив(ЧислоВходов));
	КартаКохонена.Вставить("Кластеры",Новый Массив);
	
	Для ш=0 по ЧислоВходов-1 Цикл		
		КартаКохонена.Входы[ш] = Новый Структура("Сигнал,Поз",ТаблицаВходов[ш].Сигнал,ш);		
	КонецЦикла;
	
	Для в=0 по Высота-1 Цикл
		Для ш=0 по Ширина-1 Цикл
			КартаКохонена.Нейроны[в][ш] = Новый Структура();
			КартаКохонена.Нейроны[в][ш].Вставить("ПозВысота",в);
			КартаКохонена.Нейроны[в][ш].Вставить("ПозШирина",ш);
			КартаКохонена.Нейроны[в][ш].Вставить("GUID",Строка(Новый UUID()));
			КартаКохонена.Нейроны[в][ш].Вставить("Цвет",Новый Структура("R,G,B",0,0,0));
			КартаКохонена.Нейроны[в][ш].Вставить("Кластер","-");
			КартаКохонена.Нейроны[в][ш].Вставить("ЧислоПобед",0);
			КартаКохонена.Нейроны[в][ш].Вставить("ИмяНейронаДоминатора","");
			КартаКохонена.Нейроны[в][ш].Вставить("Имя","нейрон "+в+"-"+ш);
			КартаКохонена.Нейроны[в][ш].Вставить("Веса",Новый Массив(ЧислоВходов));			
			КартаКохонена.Нейроны[в][ш].Вставить("ПобедившиеНейроны",Новый Соответствие);			
			Для стр=0 по ЧислоВходов-1 Цикл
				КартаКохонена.Нейроны[в][ш].Веса[стр] = Новый Структура("Значение",ГСЧ.СлучайноеЧисло(0,100));
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьНейронПобедитель(КартаКохонена, ВходнойВектор)
	
	КоличествоОбновляемыхНейронов = 0;
	
	// 1 определим победителя
	НейронПобедитель = Новый Структура("Дистанция,ПозВысота,ПозШирина,GUID,Кластер,Имя",100000000000,0,0,"","","");
	Для в=0 по КартаКохонена.Высота-1 Цикл
		Для ш=0 по КартаКохонена.Ширина-1 Цикл
			Дистанция = ПолучитьДистанцию(ВходнойВектор,КартаКохонена.Нейроны[в][ш].Веса);		
			Если Дистанция<НейронПобедитель.Дистанция Тогда
				НейронПобедитель.Дистанция=Дистанция;
				НейронПобедитель.ПозВысота = в;
				НейронПобедитель.ПозШирина = ш;
				НейронПобедитель.GUID = КартаКохонена.Нейроны[в][ш].GUID;
				НейронПобедитель.Имя = КартаКохонена.Нейроны[в][ш].Имя;
			КонецЕсли;				
		КонецЦикла;
	КонецЦикла;
	
	Возврат НейронПобедитель;

КонецФункции

//&Наклиенте
&НаКлиентеНаСервереБезКонтекста
Процедура ИтерацияОбучения(КартаКохонена, ВходнойВектор, Кластер, Цвет, НомерИтерации, КешВычислений)
	
	КоличествоОбновляемыхНейронов = 0;
	
	//// 1 определим победителя
	НейронПобедитель = ПолучитьНейронПобедитель(КартаКохонена,ВходнойВектор);
	
	Нейрон = КартаКохонена.Нейроны[НейронПобедитель.ПозВысота][НейронПобедитель.ПозШирина];
	Нейрон.ЧислоПобед = Нейрон.ЧислоПобед+1;
	Нейрон.Кластер = Кластер;
	
	// 2 подгоним веса
	Для в=0 по КартаКохонена.Высота-1 Цикл
		Для ш=0 по КартаКохонена.Ширина-1 Цикл
			Нейрон = КартаКохонена.Нейроны[в][ш];
			КоэффТопологическойОкрестности = КоэффТопологическойОкрестности(КартаКохонена,НейронПобедитель,Нейрон,НомерИтерации,КешВычислений);
			Если КоэффТопологическойОкрестности=0 Тогда
				Продолжить;
			КонецЕсли;
			КоличествоОбновляемыхНейронов=КоличествоОбновляемыхНейронов+1;
			СкоростьОбучения = СкоростьОбучения(НомерИтерации);
			ОбновитьЦветНейрона(Нейрон,Цвет,СкоростьОбучения,КоэффТопологическойОкрестности);
			Для стр=0 по КартаКохонена.ЧислоВходов-1 Цикл
				Нейрон.Веса[стр].Значение = 
					Окр(Нейрон.Веса[стр].Значение
					+СкоростьОбучения*КоэффТопологическойОкрестности*(ВходнойВектор[стр].Значение-Нейрон.Веса[стр].Значение),5);
				Победы = Нейрон.ПобедившиеНейроны.Получить(НейронПобедитель.Имя);
				Если Победы=Неопределено Тогда
					Победы = 0;
				КонецЕсли;
				Нейрон.ПобедившиеНейроны.Вставить(НейронПобедитель.Имя,Победы+1);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры


//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Процедура ОбновитьЦветНейрона(Нейрон,Цвет,СкоростьОбучения,Коэф=1)
	
	Коэф2 = 1;
	
	Нейрон.Цвет.R = Окр(Нейрон.Цвет.R+Коэф2*Коэф*СкоростьОбучения*(Цвет.R-Нейрон.Цвет.R),3);
	Нейрон.Цвет.G = Окр(Нейрон.Цвет.G+Коэф2*Коэф*СкоростьОбучения*(Цвет.G-Нейрон.Цвет.G),3);
	Нейрон.Цвет.B = Окр(Нейрон.Цвет.B+Коэф2*Коэф*СкоростьОбучения*(Цвет.B-Нейрон.Цвет.B),3);
	
КонецПроцедуры

//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Функция КоэффТопологическойОкрестности(КартаКохонена,ПозПобедившегоНейрона,ПозНейрона,НомерИтерации,КешВычислений)
	
	Значение = 0;
	ЭффективнаяШирина = ПолучитьЭффективнуюШирину(КартаКохонена,НомерИтерации);
	
	Значение = Окр(Exp(-КвадратЛитеральнойДистанции(ПозПобедившегоНейрона,ПозНейрона,КешВычислений)/(2*ЭффективнаяШирина*ЭффективнаяШирина)),5);
	
	Возврат Значение;
	
КонецФункции

//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Функция КвадратЛитеральнойДистанции(ПозПобедившегоНейрона,ПозНейрона,КешВычислений)
	
	Дистанция = 0;
	
	Дистанция = КешВычислений.КешЛитеральнойДистанции.Получить(ПозПобедившегоНейрона.GUID+"/"+ПозНейрона.GUID);
	
	Если Дистанция=Неопределено Тогда
		Дистанция = (ПозПобедившегоНейрона.ПозВысота-ПозНейрона.ПозВысота)*(ПозПобедившегоНейрона.ПозВысота-ПозНейрона.ПозВысота)
			+(ПозПобедившегоНейрона.ПозШирина-ПозНейрона.ПозШирина)*(ПозПобедившегоНейрона.ПозШирина-ПозНейрона.ПозШирина);
		КешВычислений.КешЛитеральнойДистанции.Вставить(ПозПобедившегоНейрона.GUID+"/"+ПозНейрона.GUID,Дистанция);
	КонецЕсли;
	
	Возврат Дистанция; 
	
КонецФункции

//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьЭффективнуюШирину(КартаКохонена,НомерИтерации)
	
	ЭффективнаяШирина = 0;
	НачальнаяЭффективнаяШирина = Окр((КартаКохонена.Высота+КартаКохонена.Ширина)/2,0); // берем радиусом решетки
	КонстантаЗатухания = 1000/Log(НачальнаяЭффективнаяШирина);
	
	ЭффективнаяШирина = НачальнаяЭффективнаяШирина*Exp(-НомерИтерации/КонстантаЗатухания);
	
	Возврат ЭффективнаяШирина;
КонецФункции

//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Функция СкоростьОбучения(НомерИтерации)
	Скорость = 0;
	НачальнаяСкорость = 0.1;
	ПараметрЗатухания = 1000;
	
	Скорость = НачальнаяСкорость*Exp(-НомерИтерации/ПараметрЗатухания);
	Если Скорость<0.01 Тогда
		Скорость=0.01;
	КонецЕсли;
	
	Возврат Скорость;
КонецФункции

//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьДистанцию(Вект1,Вект2)
	Дистанция = 0;
	
	Для ш=0 по Вект1.Количество()-1 Цикл
		Разн = Вект1[ш].Значение-Вект2[ш].Значение;
		Дистанция = Дистанция+Разн*Разн;
	КонецЦикла;
	
	Дистанция = Окр(Sqrt(Дистанция),5);
	
	Возврат Дистанция;
КонецФункции

//&НаКлиенте
&НаКлиентеНаСервереБезКонтекста
Процедура НайтиНейроныДоминаторы(КартаКохонена)
	
	Для в=0 по КартаКохонена.Высота-1 Цикл
		Для ш=0 по КартаКохонена.Ширина-1 Цикл
			
			Побед = 0;
			Для каждого стр из КартаКохонена.Нейроны[в][ш].ПобедившиеНейроны Цикл
				Если Побед<стр.Значение Тогда
					КартаКохонена.Нейроны[в][ш].ИмяНейронаДоминатора=стр.Ключ;
					Побед=стр.Значение;
				КонецЕсли;
			КонецЦикла;
			КартаКохонена.Нейроны[в][ш].ПобедившиеНейроны = Новый Соответствие;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

#конецОбласти


#Область КохоненОбработка

&НаКлиенте
Процедура ОбработатьВходныеДанныеНейроннойСетью(Команда)
	
	Если НейроннаяСетьКартаКохонена=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// формируем пакет данных
	ТаблицаАнализа.Очистить();
	ш=0;
	Для каждого стр из ТаблицаДанных Цикл
		Вектор = Новый Массив;
		ш=ш+1;
		
		Для каждого вход из ТаблицаВходов Цикл
			ИмяСвойства = НайтиИмяВходаТаблицыДанных(вход.Сигнал);
			Вектор.Добавить(Новый Структура("Значение",стр[ИмяСвойства]));		
		КонецЦикла;
		
		НейронПобедитель = ПолучитьНейронПобедитель(НейроннаяСетьКартаКохонена,Вектор);
		Нейрон = НейроннаяСетьКартаКохонена.Нейроны[НейронПобедитель.ПозВысота][НейронПобедитель.ПозШирина];
		стр_н = ТаблицаАнализа.Добавить();
		стр_н.ДатаВремя = стр[ИмяКолонкиДатаВремя];
		стр_н.НомерШага = ш;
		стр_н.Нейрон = Нейрон.Имя;
		стр_н.Кластер = Нейрон.Кластер;
		стр_н.Оценка = НейронПобедитель.Дистанция;
		
	КонецЦикла;
	
	
	ПерерисоватьГрафикОЦенки();
	
	//ПолучимШлейф
	Если ТаблицаАнализа.Количество()>10 Тогда
		ПозицияПоВремени = ТаблицаАнализа[10].ДатаВремя;
	ИначеЕсли ТаблицаДанных.Количество()>0 Тогда
		ПозицияПоВремени = ТаблицаАнализа[0].ДатаВремя;
	КонецЕсли;
	СформироватьШлейфХвостаSOM();

КонецПроцедуры

&НаКлиенте
Процедура СформироватьШлейфХвостаSOM()
	
	ШлейфДинамика = Новый Соответствие;
	
	ш=ТаблицаАнализа.Количество();
	счетчик_длины=НавигацияДлинаХвоста;
	Пока ш>0 Цикл
		ш=ш-1;
		стр = ТаблицаАнализа[ш];
		Если стр.ДатаВремя<=ПозицияПоВремени Тогда
			счетчик_длины = счетчик_длины-1;
			Если ШлейфДинамика.Получить(стр.Нейрон)=Неопределено Тогда
				ШлейфДинамика.Вставить(стр.Нейрон,Новый Структура("Размер",счетчик_длины+1));
				// завершили длину хвоста
				Если счетчик_длины=0 Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	НарисоватьТаблицуHTML(НейроннаяСетьКартаКохонена,"HTMLКартаДинамика",ШлейфДинамика);

КонецПроцедуры


&НаКлиенте
Процедура ПерерисоватьГрафикОЦенки()
	
	ДиаграммаОценки.Очистить();
	ДиаграммаОценки.ТипДиаграммы=ТипДиаграммы.График;
	
	СерияОкно = ДиаграммаОценки.УстановитьСерию("Оценка");
	//СерияПорог = ДиаграммаОценки.УстановитьСерию("Порог");
	
	Интервал = ДиаграммаОценки.ИнформационныеИнтервалыЗначений.Добавить();
	Интервал.Начало = ПорогАномалии;
	Интервал.Конец = 1500;
	Интервал.Цвет = Новый Цвет(255, 200, 100);
	Интервал.ПроцентПолупрозрачности = 80;
	Интервал.ТекстПодписи = "Аномалия";	
	
	Интервал = ДиаграммаОценки.ИнформационныеИнтервалыЗначений.Добавить();
	Интервал.Начало = 0;
	Интервал.Конец = ПорогАномалии;
	Интервал.Цвет = Новый Цвет(200, 255, 200);
	Интервал.ПроцентПолупрозрачности = 80;
	Интервал.ТекстПодписи = "Норма";	
	
	Для каждого стр из ТаблицаАнализа Цикл
		ТочкаДиаграммы = ДиаграммаОценки.УстановитьТочку(стр.ДатаВремя);
		// добавим значение	
		ДиаграммаОценки.УстановитьЗначение(ТочкаДиаграммы, СерияОкно, стр.Оценка);
		//ДиаграммаОценки.УстановитьЗначение(ТочкаДиаграммы, СерияПорог, ПорогАномалии);
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

&НаКлиенте
Процедура ИнициализироватьКартыКохонена(Команда)
	
	ТекущаяИтерация = 0;
	КоличествоОбновляемыхНейронов = ШиринаСети*ВысотаСети;
	
	Если ТестСети=Истина Тогда
		Если НЕ (ЧислоВходовСети=2 ИЛИ ЧислоВходовСети=3) Тогда
			ЧислоВходовСети=2;
		КонецЕсли;
	КонецЕсли;
	
	ИнициализироватьКартуКохонена(НейроннаяСетьКартаКохонена,ЧислоВходовСети,ВысотаСети,ШиринаСети);
	
	ИнициализироватьТаблицуНейронов();
	
КонецПроцедуры

&НаКлиенте
Процедура ИнициализироватьТаблицуНейронов()
	
	Колонки = Новый Массив;
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Булево"));
	МассивТипов.Добавить(Тип("Дата"));
	КС = Новый КвалификаторыСтроки(200);
	КЧ = Новый КвалификаторыЧисла(20,3);
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов, , ,КЧ, КС);
	ОписаниеЧисло = Новый ОписаниеТипов("Число", , ,КЧ);	
	
	Колонки = Новый массив;
	
	Для ш=1 по ШиринаСети Цикл
		Колонки.Добавить(Новый Структура("Имя,Ключ,ТипСтрокой,ТипЗначения,Ширина,Заголовок,ИмяКолонки,ИмяСледующегоЭлемента,ТолькоПросмотр,Видимость",
		"neuron_"+ш,"neuron_"+ш,"Строка",ОписаниеТипов,10,"neuron "+ш,"neuron_"+ш,Неопределено,Истина,Истина));
	КонецЦикла;
	
	СоздатьДинамическиеКолонкиТаблицы("СеткаНейронов",Колонки,СтарыеКолонкиТаблицаКохонена,);
	СтарыеКолонкиТаблицаКохонена = Колонки;
	
	ОбновитьСеткуНейронов();
	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьСеткуНейронов()
	
	Перем в, Нейрон, стр_н, ш;
	
	// заполним данными
	СеткаНейронов.Очистить();
	Для в=0 по ВысотаСети-1 Цикл
		стр_н = СеткаНейронов.Добавить();
		Для ш = 0 по ШиринаСети-1 Цикл
			Нейрон = НейроннаяСетьКартаКохонена.Нейроны[в][ш];
			веса="";
			Для каждого поз из Нейрон.Веса Цикл
				веса=веса+" "+Формат(поз.Значение,"ЧДЦ=1");
			КонецЦикла;
			//стр_н["neuron_"+(ш+1)] = Нейрон.Имя+"("+Нейрон.ЧислоПобед+") "+веса;
			стр_н["neuron_"+(ш+1)] =  "("+Нейрон.ЧислоПобед+") "+Нейрон.Кластер+веса;
		КонецЦикла;
	КонецЦикла;

	НарисоватьТаблицуHTML(НейроннаяСетьКартаКохонена,"HTMLКарта");
	
КонецПроцедуры

&НаКлиенте
Процедура НарисоватьТаблицуHTML(КартаКохонена,ИмяHTML,ШлейфДинамика=Неопределено)
	
	CSS = "<style>
	| table {border: 1px solid blue;}
	| td {border: 1px solid grey; min-width:40px;min-height:40px;}
	| th {border: 1px solid black;}
	| td {
	| font-size: 11px;	}
	| span {background-color: #ccc;}
	|</style>";
	HTML = "<html><head>SOM</head>"+CSS+"<body>";
	
	
	// заполним данными
	HTML=HTML+"<table>";
	HTML=HTML+"<th></th>";
	Для ш = 0 по ШиринаСети-1 Цикл
		HTML=HTML+"<th>"+ш+"</th>";
	КонецЦикла;
	Для в=0 по ВысотаСети-1 Цикл
		HTML=HTML+"<tr><th>"+в+"</th>";
		Для ш = 0 по ШиринаСети-1 Цикл
			Нейрон = НейроннаяСетьКартаКохонена.Нейроны[в][ш];
			веса="";
			Для каждого поз из Нейрон.Веса Цикл
				веса=веса+" "+Формат(поз.Значение,"ЧДЦ=1");
			КонецЦикла;
			//стр_н["neuron_"+(ш+1)] = Нейрон.Имя+"("+Нейрон.ЧислоПобед+") "+веса;
			Если ОтображениеСетки="ничего" Тогда
				текст="";
			ИначеЕсли ОтображениеСетки="победы" Тогда
				текст =  ""+Нейрон.ЧислоПобед+"";
			ИначеЕсли ОтображениеСетки="кластер" Тогда
				текст =  ""+Нейрон.Кластер+"";
			ИначеЕсли ОтображениеСетки="доминатор" Тогда
				текст = ""+Нейрон.ИмяНейронаДоминатора+"";
			ИначеЕсли ОтображениеСетки="все" Тогда
				текст =  "("+Нейрон.ЧислоПобед+") "+Нейрон.Кластер+веса;
			КонецЕсли;				
			мЗаголовок = Нейрон.Имя+" ("+Нейрон.ЧислоПобед+") "+Нейрон.Кластер+веса;
			Style = " background-color: RGB("+Формат(Нейрон.Цвет.R,"ЧДЦ=0; ЧН=0")+","+Формат(Нейрон.Цвет.G,"ЧДЦ=0; ЧН=0")+","+Формат(Нейрон.Цвет.B,"ЧДЦ=0; ЧН=0")+"); ";
			
			// добавим шлейф
			Если НЕ ШлейфДинамика=Неопределено Тогда
				
				вр_нейрон = ШлейфДинамика.Получить(Нейрон.Имя);
				Если НЕ вр_нейрон=Неопределено Тогда
					цвет = XMLСтрока(10*НавигацияДлинаХвоста-(НавигацияДлинаХвоста-вр_нейрон.Размер)*10);
					Style = Style+" border-width: "+вр_нейрон.Размер+"px; border-style: solid; border-color: RGB("+цвет+","+цвет+","+цвет+"); ";
				КонецЕсли;
								
			КонецЕсли;

			HTML=HTML+"<td style='"+Style+"' title='"+мЗаголовок+"' ><span>"+текст+"</span></td>";
		КонецЦикла;
		HTML=HTML+"</tr>";
	КонецЦикла;
	HTML=HTML+"</table>";
	
	
	HTML = HTML+"</body></html>";
	ЭтаФорма[ИмяHTML] = HTML;
	
КонецПроцедуры

&НаСервере
Процедура ИнициализироватьКартыКохоненаСервер() 
	//ПрограммноеИзменениеФормСервер.
КонецПроцедуры


&НаКлиенте
Процедура ОбучитьСетьКохонена(Команда)
	
	ЧислоИтераций = ШагИтерации;
	СоответсвиеЦветов = Новый Соответствие;
	
	Для каждого стр из ТаблицаОписанияКластеров Цикл
		Цвет = Новый Структура;
		Цвет.Вставить("R",стр.Red);
		Цвет.Вставить("G",стр.Green);
		Цвет.Вставить("B",стр.Blue);
		СоответсвиеЦветов.Вставить(стр.Кластер,Цвет);
	КонецЦикла;
	
	Если ТестСети=Истина Тогда
		
		МассивВекторов = Новый Массив;
		Для каждого стр из ТестовыеДанные Цикл
			Вектор = Новый Массив;
			Вектор.Добавить(Новый Структура("Значение",стр.X));
			Вектор.Добавить(Новый Структура("Значение",стр.Y));
			Если ЧислоВходовСети=3 Тогда
				Вектор.Добавить(Новый Структура("Значение",стр.Z));
			КонецЕсли;
			Цвет = СоответсвиеЦветов.Получить(стр.Кластер);
			Если Цвет=Неопределено Тогда
				Цвет = Новый Структура("R,G,B",150,150,150);
			КонецЕсли;
			МассивВекторов.Добавить(Новый Структура("Вектор,Кластер,Цвет",Вектор,стр.Кластер,Цвет));
		КонецЦикла;
		
		ВходнойВектор = Новый Массив;
		Для НомерИтерации=0 по ЧислоИтераций Цикл
			Для Каждого стр из МассивВекторов Цикл
				ИтерацияОбучения(НейроннаяСетьКартаКохонена,стр.Вектор,стр.Кластер,стр.Цвет,ТекущаяИтерация+НомерИтерации,КешВычисленийНейроннаяСеть);
			КонецЦикла;				
		КонецЦикла;
		ТекущаяИтерация=ТекущаяИтерация+ЧислоИтераций;
	Иначе
		//МассивВекторов = Модуль_ВекторноеПространство.ПолучитьМассивВекторов(мНастройки_ВекторноеПространство);
		
		МассивВекторов = Новый Массив; // TODO получить данные
		Для каждого стр из ТаблицаДанных Цикл
			Вектор = Новый Массив;
			
			Для каждого вход из ТаблицаВходов Цикл
				ИмяСвойства = НайтиИмяВходаТаблицыДанных(вход.Сигнал);
				Вектор.Добавить(Новый Структура("Значение",стр[ИмяСвойства]));		
			КонецЦикла;
			
			Цвет = СоответсвиеЦветов.Получить(стр[ИмяКолонкиКластер]);
			Если Цвет=Неопределено Тогда
				Цвет = Новый Структура("R,G,B",150,150,150);
			КонецЕсли;
			МассивВекторов.Добавить(Новый Структура("Вектор,Кластер,Цвет",Вектор,стр[ИмяКолонкиКластер],Цвет));	
			
		КонецЦикла;
		
		ВходнойВектор = Новый Массив;
		Для НомерИтерации=0 по ЧислоИтераций Цикл
			Для Каждого стр из МассивВекторов Цикл
				Цвет = СоответсвиеЦветов.Получить(стр.Кластер);
				Если Цвет=Неопределено Тогда
					Цвет = Новый Структура("R,G,B",150,150,150);
				КонецЕсли;
				ИтерацияОбучения(НейроннаяСетьКартаКохонена,стр.Вектор,стр.Кластер,Цвет,ТекущаяИтерация+НомерИтерации,КешВычисленийНейроннаяСеть);
			КонецЦикла;				
		КонецЦикла;
		// найдем нейроны доминаторы
		НайтиНейроныДоминаторы(НейроннаяСетьКартаКохонена);
		ТекущаяИтерация=ТекущаяИтерация+ЧислоИтераций;
	КонецЕсли;
	
	ОбновитьСеткуНейронов();
	
КонецПроцедуры

&НаКлиенте
Функция ОбработатьСетьюКохонена(ВходнойВектор,КартаКохонена)
	
	Результат = Новый Структура("Оценка,Кластер",-1,"");
	
	// 1 определим победителя
	НейронПобедитель = Новый Структура("Оценка,ПозВысота,ПозШирина,GUID,Кластер",0,0,0,"","");
	Если МераОценки="дистанция" Тогда
		НейронПобедитель.Оценка=9999999999999;
	КонецЕсли;
	Для в=0 по КартаКохонена.Высота-1 Цикл
		Для ш=0 по КартаКохонена.Ширина-1 Цикл
			
			Если МераОценки="дистанция" Тогда
				Дистанция = ПолучитьДистанцию(ВходнойВектор,КартаКохонена.Нейроны[в][ш].Веса);		
				Если Дистанция<НейронПобедитель.Оценка Тогда
					НейронПобедитель.Оценка=Дистанция;
					НейронПобедитель.ПозВысота = в;
					НейронПобедитель.ПозШирина = ш;
					НейронПобедитель.GUID = КартаКохонена.Нейроны[в][ш].GUID;
					НейронПобедитель.Кластер = КартаКохонена.Нейроны[в][ш].Кластер;
				КонецЕсли;				
			Иначе
				//Косинус = Модуль_ВекторноеПространство.ПолучитьКосинусВекторов(ВходнойВектор,Неопределено,КартаКохонена.Нейроны[в][ш].Веса,Неопределено,мНастройки_ВекторноеПространство);
				//Если Косинус>НейронПобедитель.Оценка Тогда
				//	НейронПобедитель.Оценка=Косинус;
				//	НейронПобедитель.ПозВысота = в;
				//	НейронПобедитель.ПозШирина = ш;
				//	НейронПобедитель.GUID = КартаКохонена.Нейроны[в][ш].GUID;
				//	НейронПобедитель.Кластер = КартаКохонена.Нейроны[в][ш].Кластер;
				//КонецЕсли;				
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	//Нейрон = КартаКохонена.Нейроны[НейронПобедитель.ПозВысота][НейронПобедитель.ПозШирина];
	
	ЗаполнитьЗначенияСвойств(Результат,НейронПобедитель);
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Процедура ОтображениеСеткиПриИзменении(Элемент)
	НарисоватьТаблицуHTML(НейроннаяСетьКартаКохонена,"HTMLКарта");
КонецПроцедуры



#Область ЗагрузитьСохранитьНейроннуюМодель

&НаКлиенте
Функция ВыгрузитьМодельВXML(Модель)
	
	XMLСтрока = ""; 
	
	Попытка
		
		// Создать объект записи XML и открыть файл
		НоваяЗаписьXML = Новый ЗаписьXML;
		НоваяЗаписьXML.УстановитьСтроку("UTF-8");
		
		НоваяЗаписьXML.ЗаписатьОбъявлениеXML();
		
		НоваяЗаписьXML.ЗаписатьНачалоЭлемента("project");
		
			НоваяЗаписьXML.ЗаписатьАтрибут("verion",Модель.Версия);
			НоваяЗаписьXML.ЗаписатьАтрибут("type",Модель.Тип);
			НоваяЗаписьXML.ЗаписатьАтрибут("author",Модель.Автор);
			НоваяЗаписьXML.ЗаписатьАтрибут("url",Модель.url);
			НоваяЗаписьXML.ЗаписатьНачалоЭлемента("description");
				НоваяЗаписьXML.ЗаписатьТекст(СокрЛП(Модель.Описание));
			НоваяЗаписьXML.ЗаписатьКонецЭлемента();
			
			НоваяЗаписьXML.ЗаписатьНачалоЭлемента("som");
			НоваяЗаписьXML.ЗаписатьАтрибут("inputs",XMLСтрока(Модель.ЧислоВходов));
			НоваяЗаписьXML.ЗаписатьАтрибут("neurons",XMLСтрока(Модель.ЧислоНейронов));
			НоваяЗаписьXML.ЗаписатьАтрибут("clusters",XMLСтрока(Модель.Кластеры.Количество()));
			НоваяЗаписьXML.ЗаписатьАтрибут("h",XMLСтрока(Модель.Высота));
			НоваяЗаписьXML.ЗаписатьАтрибут("w",XMLСтрока(Модель.Ширина));
			
			// описание кластеров
			НоваяЗаписьXML.ЗаписатьНачалоЭлемента("clusters");
			    НоваяЗаписьXML.ЗаписатьАтрибут("amount",XMLСтрока(Модель.Кластеры.Количество()));
				Для каждого стр из Модель.Кластеры Цикл
					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("cluster");		
						НоваяЗаписьXML.ЗаписатьАтрибут("name",XMLСтрока(стр.Кластер));
						НоваяЗаписьXML.ЗаписатьАтрибут("description",XMLСтрока(стр.Описание));
						НоваяЗаписьXML.ЗаписатьНачалоЭлемента("color");
							НоваяЗаписьXML.ЗаписатьАтрибут("r",XMLСтрока(стр.Цвет.R));
							НоваяЗаписьXML.ЗаписатьАтрибут("g",XMLСтрока(стр.Цвет.G));
							НоваяЗаписьXML.ЗаписатьАтрибут("b",XMLСтрока(стр.Цвет.B));
						НоваяЗаписьXML.ЗаписатьКонецЭлемента();
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				КонецЦикла;				
			НоваяЗаписьXML.ЗаписатьКонецЭлемента();
		
			
			// Входы
			НоваяЗаписьXML.ЗаписатьНачалоЭлемента("inputs");
				НоваяЗаписьXML.ЗаписатьАтрибут("amount",XMLСтрока(Модель.ЧислоВходов));
				Для каждого стр из Модель.Входы Цикл
					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("input");		
						НоваяЗаписьXML.ЗаписатьАтрибут("id",XMLСтрока(стр.Поз));
						НоваяЗаписьXML.ЗаписатьАтрибут("name",XMLСтрока(стр.Сигнал));
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				КонецЦикла;				
			НоваяЗаписьXML.ЗаписатьКонецЭлемента();
			
			// Нейроны
			НоваяЗаписьXML.ЗаписатьНачалоЭлемента("neurons");
			НоваяЗаписьXML.ЗаписатьАтрибут("amount",XMLСтрока(Модель.ЧислоНейронов));
			Для в=0 по Модель.Высота-1 Цикл
				Для ш=0 по Модель.Ширина-1 Цикл
					
					стр = Модель.Нейроны[в][ш];

					НоваяЗаписьXML.ЗаписатьНачалоЭлемента("neuron");
					
					НоваяЗаписьXML.ЗаписатьАтрибут("GUID",XMLСтрока(стр.GUID));
					НоваяЗаписьXML.ЗаписатьАтрибут("i",XMLСтрока(стр.ПозВысота));
					НоваяЗаписьXML.ЗаписатьАтрибут("j",XMLСтрока(стр.ПозШирина));
					НоваяЗаписьXML.ЗаписатьАтрибут("name",стр.Имя);
					НоваяЗаписьXML.ЗаписатьАтрибут("cluster",стр.Кластер);
					НоваяЗаписьXML.ЗаписатьАтрибут("wins",XMLСтрока(стр.ЧислоПобед));
					
						НоваяЗаписьXML.ЗаписатьНачалоЭлемента("color");
							НоваяЗаписьXML.ЗаписатьАтрибут("r",XMLСтрока(стр.Цвет.R));
							НоваяЗаписьXML.ЗаписатьАтрибут("g",XMLСтрока(стр.Цвет.G));
							НоваяЗаписьXML.ЗаписатьАтрибут("b",XMLСтрока(стр.Цвет.B));
						НоваяЗаписьXML.ЗаписатьКонецЭлемента();
						
						НоваяЗаписьXML.ЗаписатьНачалоЭлемента("weights");
						НоваяЗаписьXML.ЗаписатьАтрибут("amount",XMLСтрока(стр.Веса.Количество()));
						Для каждого стр_в из стр.Веса Цикл 
							НоваяЗаписьXML.ЗаписатьНачалоЭлемента("weight");
								НоваяЗаписьXML.ЗаписатьАтрибут("value",XMLСтрока(стр_в.Значение));
							НоваяЗаписьXML.ЗаписатьКонецЭлемента();
						КонецЦикла;
						НоваяЗаписьXML.ЗаписатьКонецЭлемента(); 					
					
					НоваяЗаписьXML.ЗаписатьКонецЭлемента();
				КонецЦикла;	
			КонецЦикла;
			НоваяЗаписьXML.ЗаписатьКонецЭлемента();// som
			
		НоваяЗаписьXML.ЗаписатьКонецЭлемента();         
			
		// Конец основного тега
		НоваяЗаписьXML.ЗаписатьКонецЭлемента();         
		XMLСтрока = НоваяЗаписьXML.Закрыть();
		
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Сообщить(ТекстОшибки);
		XMLСтрока = "";
	КонецПопытки;

	Возврат XMLСтрока;
	
КонецФункции


&НаКлиенте
Функция ЗагрузитьМодельXML(ПутьКФайлу)
	
	Модель = Новый Структура();
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	
	Попытка
		ЧтениеXML.ОткрытьФайл(сокрЛП(ПутьКфайлу));
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.Имя = "project" Тогда
			Модель.Вставить("Автор",ЧтениеXML.ПолучитьАтрибут("author"));
			Модель.Вставить("url",ЧтениеXML.ПолучитьАтрибут("url"));
			Модель.Вставить("Версия",ЧтениеXML.ПолучитьАтрибут("verion"));
			Модель.Вставить("Тип",ЧтениеXML.ПолучитьАтрибут("type"));
			
			
		ИначеЕсли ЧтениеXML.Имя = "description"  И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
			
			ЧтениеXML.Прочитать();	
			Модель.Вставить("Описание",ЧтениеXML.Значение);
			
		ИначеЕсли ЧтениеXML.Имя = "som" Тогда
			
			Модель.Вставить("Высота",Число(ЧтениеXML.ПолучитьАтрибут("h")));
			Модель.Вставить("Ширина",Число(ЧтениеXML.ПолучитьАтрибут("w")));
			Модель.Вставить("ЧислоВходов",Число(ЧтениеXML.ПолучитьАтрибут("inputs")));
			Модель.Вставить("Нейроны",Новый Массив(Модель.Высота,Модель.Ширина));
			Модель.Вставить("Входы",Новый Массив(Модель.ЧислоВходов));
			Модель.Вставить("Кластеры",Новый Массив);
			
			Пока ЧтениеXML.Прочитать() Цикл
				
				Если ЧтениеXML.Имя = "neurons" Тогда
					
					Модель.Вставить("ЧислоНейронов",Число(ЧтениеXML.ПолучитьАтрибут("amount")));
					
					Пока ЧтениеXML.Прочитать() Цикл
						Если ЧтениеXML.Имя = "neurons" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Прервать;
						ИначеЕсли ЧтениеXML.Имя = "neuron" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
							Нейрон = Новый Структура();
							Нейрон.Вставить("GUID",ЧтениеXML.ПолучитьАтрибут("GUID"));
							Нейрон.Вставить("ПозВысота",Число(ЧтениеXML.ПолучитьАтрибут("i")));
							Нейрон.Вставить("ПозШирина",Число(ЧтениеXML.ПолучитьАтрибут("j")));
							Нейрон.Вставить("ЧислоПобед",Число(ЧтениеXML.ПолучитьАтрибут("wins")));
							Нейрон.Вставить("Имя",ЧтениеXML.ПолучитьАтрибут("name"));
							Нейрон.Вставить("Кластер",ЧтениеXML.ПолучитьАтрибут("cluster"));
							Нейрон.Вставить("Цвет",Новый Структура("R,G,B",155,155,155));
							Нейрон.Вставить("Веса",Новый Массив);
							Нейрон.Вставить("ИмяНейронаДоминатора","");
							Нейрон.Вставить("ПобедившиеНейроны",Новый Соответствие);			
							
							// загрузим веса
							
							Пока ЧтениеXML.Прочитать() Цикл
								
								Если ЧтениеXML.Имя = "neuron" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
									Прервать;
								ИначеЕсли ЧтениеXML.Имя = "color" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
									Цвет = Новый Структура();
									Цвет.Вставить("R",Число(ЧтениеXML.ПолучитьАтрибут("r")));
									Цвет.Вставить("G",Число(ЧтениеXML.ПолучитьАтрибут("g")));
									Цвет.Вставить("B",Число(ЧтениеXML.ПолучитьАтрибут("b")));
									Нейрон.Вставить("Цвет",Цвет);
								ИначеЕсли ЧтениеXML.Имя = "weights" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
									//Веса = Новый Массив(Число(ЧтениеXML.ПолучитьАтрибут("amount")));
									Веса = Новый Массив();
									Пока ЧтениеXML.Прочитать() Цикл
										Если ЧтениеXML.Имя = "weights" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
											Нейрон.Вставить("Веса",Веса);
											Прервать;
										ИначеЕсли ЧтениеXML.Имя = "weight" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
											Веса.Добавить(Новый Структура("Значение",Число(ЧтениеXML.ПолучитьАтрибут("value"))));
										КонецЕсли;
									КонецЦикла;
								КонецЕсли;
								
							КонецЦикла;
							
							Модель.Нейроны[Нейрон.ПозВысота][Нейрон.ПозШирина]=Нейрон;  				
							
							Если ЧтениеXML.Имя = "neurons" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
								Прервать;
							КонецЕсли;
							
						КонецЕсли;
					КонецЦикла;
				ИначеЕсли ЧтениеXML.Имя = "inputs" Тогда 
					Модель.Входы = Новый Массив;
					Пока ЧтениеXML.Прочитать() Цикл
						Если ЧтениеXML.Имя = "inputs" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Прервать;
						ИначеЕсли ЧтениеXML.Имя = "input" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
							Модель.Входы.Добавить(Новый Структура("Сигнал,Поз",ЧтениеXML.ПолучитьАтрибут("name"),Число(ЧтениеXML.ПолучитьАтрибут("id"))));
						КонецЕсли;
					КонецЦикла;					
				ИначеЕсли ЧтениеXML.Имя = "clusters" Тогда 
					Модель.Кластеры = Новый Массив;
					Кластер = Неопределено;
					Пока ЧтениеXML.Прочитать() Цикл
						Если ЧтениеXML.Имя = "clusters" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Прервать;
						ИначеЕсли ЧтениеXML.Имя = "cluster" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
							Кластер = Новый Структура("Кластер,Описание,Цвет",ЧтениеXML.ПолучитьАтрибут("name"),ЧтениеXML.ПолучитьАтрибут("description"),Новый Структура("r,g,b",155,155,155));
						ИначеЕсли ЧтениеXML.Имя = "cluster" И ЧтениеXML.ТипУзла=ТипУзлаXML.КонецЭлемента Тогда
							Модель.Кластеры.Добавить(Кластер);
						ИначеЕсли ЧтениеXML.Имя = "color" И ЧтениеXML.ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
							Цвет = Новый Структура();
							Цвет.Вставить("R",Число(ЧтениеXML.ПолучитьАтрибут("r")));
							Цвет.Вставить("G",Число(ЧтениеXML.ПолучитьАтрибут("g")));
							Цвет.Вставить("B",Число(ЧтениеXML.ПолучитьАтрибут("b")));
							Кластер.Вставить("Цвет",Цвет);
						КонецЕсли;
					КонецЦикла;					
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Модель;
КонецФункции


#КонецОбласти


&НаКлиенте
Процедура ЗагрузитьМодель(Команда)
	Если НЕ ЗначениеЗаполнено(ПутьКНейроннаяСеть) Тогда
		Сообщить("Укажите путь к Файлу модели!");
		Возврат;
	КонецЕсли;
	
	КешВычисленийНейроннаяСеть = Новый Структура();
	КешВычисленийНейроннаяСеть.Вставить("КешЛитеральнойДистанции",Новый Соответствие);
	
	НейроннаяСетьКартаКохонена = ЗагрузитьМодельXML(ПутьКНейроннаяСеть);
	
	Если НейроннаяСетьКартаКохонена=Неопределено Тогда
		Сообщить("Ошибка загрузки файла");
		Возврат;
	КонецЕсли;
	
	ЗаполнитьДанныеФормыПоСтруктуре(НейроннаяСетьКартаКохонена);
	ИнициализироватьТаблицуНейронов();
	НарисоватьТаблицуHTML(НейроннаяСетьКартаКохонена,"HTMLКарта");
	
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьДанныеФормыПоСтруктуре(Модель)
	
	ШиринаСети = Модель.Ширина;
	ВысотаСети = Модель.Высота;
	ЧислоВходовСети = Модель.ЧислоВходов;
	
	ТаблицаВходов.Очистить();
	Для каждого стр из Модель.Входы Цикл
		стр_н = ТаблицаВходов.Добавить();
		стр_н.Номер = стр.Поз;
		стр_н.Сигнал = стр.Сигнал;
	КонецЦикла;
	
	ТаблицаОписанияКластеров.Очистить();
	Для каждого стр из Модель.Кластеры Цикл
		стр_н = ТаблицаОписанияКластеров.Добавить();
		стр_н.Кластер = стр.Кластер;
		стр_н.Описание = стр.Описание;
		стр_н.Red = стр.Цвет.r;
		стр_н.Green = стр.Цвет.g;
		стр_н.Blue = стр.Цвет.b;
	КонецЦикла;
	
	ОбновитьПараметрыВыбораВходов();
	
КонецПроцедуры


&НаКлиенте
Процедура СохранитьМодель(Команда)
	Если НЕ ЗначениеЗаполнено(ПутьКНейроннаяСеть) Тогда
		Сообщить("Укажите путь к Файлу модели!");
		Возврат;
	КонецЕсли;
	
	//Модель = СформироватьСтруктуруПоДаннымФормы();
	ОбновитьКластерыМодели(НейроннаяСетьКартаКохонена);
	ТекстоваяСтрокаФайла = ВыгрузитьМодельВXML(НейроннаяСетьКартаКохонена);
	
	Если ТекстоваяСтрокаФайла="" Тогда
		Возврат;
	КонецЕсли;
	
	Документ = Новый ТекстовыйДокумент;
	Документ.УстановитьТекст(ТекстоваяСтрокаФайла);
	СохранениеФайлаПроекта = Новый ОписаниеОповещения("СохранениеФайлаПроекта",ЭтотОбъект);
	Документ.НачатьЗапись(СохранениеФайлаПроекта,ПутьКНейроннаяСеть,"UTF-8");
	
	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьКластерыМодели(НейроннаяСеть)
	
	Если НейроннаяСеть=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НейроннаяСеть.Кластеры = Новый Массив;
	Для каждого стр из ТаблицаОписанияКластеров Цикл
		Кластер = Новый Структура();
		Кластер.Вставить("Кластер",стр.Кластер);
		Кластер.Вставить("Описание",стр.Описание);
		Кластер.Вставить("Цвет",Новый Структура);
		Кластер.Цвет.Вставить("r",стр.Red);
		Кластер.Цвет.Вставить("g",стр.Green);
		Кластер.Цвет.Вставить("b",стр.Blue);
		НейроннаяСеть.Кластеры.Добавить(Кластер);
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура СохранениеФайлаПроекта(Результат, ДополнительныеПараметры) Экспорт
	
	Если Результат=Истина Тогда
		Сообщить("Файл записан успешно!");
	Иначе
		Сообщить("При сохранении файла произошла ошибка!");	
	КонецЕсли;
	
КонецПроцедуры


#Область ЗагрузкаСохранениеCSV

&НаКлиенте
Функция РазобратьФайлВТаблицуCSV(ПутьКФайлу) Экспорт
	
	ИмяФайлаДляРазбора 	= ПутьКФайлу;
	КолонкиТаблицыДанных.Очистить();
	
	
	//пропуск пустых файлов
	ФайлТЖ = Новый Файл(ИмяФайлаДляРазбора);
	РазмерФайла = ФайлТЖ.Размер();
	Если РазмерФайла <=3 Тогда
		Сообщить("Файл пустой!");
		Возврат 0;
	КонецЕсли;
	
	ДатаНачалаЧтения = ТекущаяДата();
	
	Текст = Новый ЧтениеТекста(ИмяФайлаДляРазбора, КодировкаТекста.ANSI, Символы.ВК + Символы.ПС, "", Ложь);
	
	// Всегда читаем перую строку для свойств
	СтрокаТекста = Текст.ПрочитатьСтроку();
	ПрочитаноСтрок = 0;
	
	// разделение по csv запятая
	СтрокаТекста = СтрЗаменить(СтрокаТекста,"(PDH-CSV 4.0) (RTZ 2 (","Время");
	МассивИменСвойств = СтрРазделить(СтрокаТекста,",",Ложь); 
	
	// нормализуем параметры
	Для ш=0 по МассивИменСвойств.ВГраница() Цикл
		МассивИменСвойств[ш] = СтрЗаменить(МассивИменСвойств[ш],"""","");
		Если Найти(МассивИменСвойств[ш],"\\") Тогда
			МассивЧастей = СтрРазделить(СтрЗаменить(МассивИменСвойств[ш],"\\",""),"\");
			Если Найти(МассивЧастей[1],":") Тогда
				МассивЧастейСКЛ = СтрРазделить(МассивЧастей[1],":");
				МассивЧастей[1]=СокрЛП(МассивЧастейСКЛ[1]);
			КонецЕсли;
			МассивИменСвойств[ш] = СокрЛП(МассивЧастей[1]+"\"+МассивЧастей[2]);
		КонецЕсли;
	КонецЦикла;
	
	// Сформируем таблицу, данных
	Колонки = Новый Массив;
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Дата"));
	МассивТипов.Добавить(Тип("Булево"));
	КС = Новый КвалификаторыСтроки(20);
	КЧ = Новый КвалификаторыЧисла(20,10);
	КЧЦ = Новый КвалификаторыЧисла(20,0);
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов, , ,КЧ, КС);
	ОписаниеСтрока = Новый ОписаниеТипов("Строка", , , , КС);
	ОписаниеЧисло = Новый ОписаниеТипов("Число", , ,КЧ);	
	ОписаниеЧислоЦелое = Новый ОписаниеТипов("Число", , ,КЧЦ);	
	ОписаниеДата = Новый ОписаниеТипов("Дата", , ,КЧЦ);	

	Если МассивИменСвойств.Найти("№")=Неопределено Тогда
		Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","НомерСтроки",ОписаниеЧислоЦелое,10,"№",Неопределено,Ложь,"Число",Истина));
	КонецЕсли;
	Если МассивИменСвойств.Найти("t")=Неопределено Тогда
		Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","ВремяЧислом",ОписаниеЧисло,10,"t",Неопределено,Ложь,"Число",Истина));
	КонецЕсли;
	Если МассивИменСвойств.Найти("date")=Неопределено Тогда
		Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","ДатаВремя",ОписаниеДата,10,"date",Неопределено,Ложь,"Дата",Истина));	
		ИмяКолонкиДатаВремя = "ДатаВремя";
	КонецЕсли;
	Если МассивИменСвойств.Найти("claster")=Неопределено Тогда
		Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","Кластер",ОписаниеСтрока,10,"claster",Неопределено,Ложь,"Число",Истина));
		ИмяКолонкиКластер = "Кластер";
	КонецЕсли;
	ш=0;
	Для каждого стр из МассивИменСвойств Цикл
		
		Если стр="t" Тогда
			Попытка
				Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","ВремяЧислом",ОписаниеТипов,10,стр,Неопределено,Ложь,"ОписаниеТипов",Истина));
			Исключение
			КонецПопытки;
		ИначеЕсли стр="№" Тогда
			Попытка
				Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","НомерСтроки",ОписаниеЧислоЦелое,10,стр,Неопределено,Ложь,"ОписаниеТипов",Истина));
			Исключение
			КонецПопытки;
		Иначе
			Если стр="date" Тогда
				ИмяКолонкиДатаВремя="Свойство_"+XMLСтрока(ш);
			ИначеЕсли стр="claster" Тогда
				ИмяКолонкиКластер="Свойство_"+XMLСтрока(ш);
			КонецЕсли;
			Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","Свойство_"+XMLСтрока(ш),ОписаниеТипов,10,стр,Неопределено,Ложь,"ОписаниеТипов",Истина));
		КонецЕсли;	
		ш=ш+1;
	КонецЦикла;
	
	Если СтарыеКолонки=Неопределено Тогда
		СтарыеКолонки = Новый Массив;
	КонецЕсли;
	
	КолонкиТаблицыДанных.Очистить();
	Для каждого стр из Колонки Цикл
		стр_н = КолонкиТаблицыДанных.Добавить();
		ЗаполнитьЗначенияСвойств(стр_н,стр);
	КонецЦикла;
	
	СоздатьДинамическиеКолонкиТаблицы("ТаблицаДанных",Колонки,СтарыеКолонки);
	
	СтарыеКолонки = Колонки;
	
	
	ПозиционироватьЧтениеНаСтрокуФайла(Текст, ПрочитаноСтрок);
	
	//продолжаем чтение с позиции СостояниеЧтения.ПрочитаноСтрок
	//СтрокаТекста = Текст.ПрочитатьСтроку();
	
	Пока СтрокаТекста <> Неопределено ИЛИ НЕ ЗначениеЗаполнено(СтрокаТекста) Цикл
		
		// Проверяем, является ли следующая строка начальной строкой журнала
		СледующаяСтрока = Текст.ПрочитатьСтроку();
		
		Если СледующаяСтрока = Неопределено ИЛИ НЕ ЗначениеЗаполнено(СледующаяСтрока) Тогда
			Прервать;	
		КонецЕсли;
		
		ПрочитаноСтрок = ПрочитаноСтрок + 1;
		
		стр_н = ТаблицаДанных.Добавить();
		стр_н.НомерСтроки = ПрочитаноСтрок;
		
		МассивЗначенийСвойств = СтрРазделить(СледующаяСтрока,",",Ложь);
		
		Для ш=0 по МассивЗначенийСвойств.ВГраница() Цикл
			
			ИмяСвойства = МассивИменСвойств[ш]; 			
			
			ЗначениеСвойства = 0;
			
			Попытка
				
				Если ЭтоДата(МассивЗначенийСвойств[ш]) Тогда
					ЗначениеСвойства = ПрочитатьДату(МассивЗначенийСвойств[ш]);
				Иначе
					Если МассивЗначенийСвойств[ш]="" Тогда  
						ЗначениеСвойства="";
					// очень маленькие будут 0
					ИначеЕсли Найти(МассивЗначенийСвойств[ш],"e-") Тогда
						ЗначениеСвойства = 0;
					Иначе
						Попытка
							ЗначениеСвойства = Число(СтрЗаменить(МассивЗначенийСвойств[ш],"""",""));
						Исключение
							ЗначениеСвойства = СтрЗаменить(МассивЗначенийСвойств[ш],"""",""); 
						КонецПопытки;
					КонецЕсли;
				КонецЕсли;
				
				стр_н["Свойство_"+XMLСтрока(ш)] = ЗначениеСвойства; 
				
			Исключение
				
				Сообщить(ОписаниеОшибки());				
				
			КонецПопытки;
			
			
		КонецЦикла;
		
		СтрокаТекста = СледующаяСтрока;
	КонецЦикла;
	
	Текст.Закрыть();
	
	
	// обработаем время в число
	Если ТаблицаДанных.Количество()>0 Тогда
		Попытка			
			// найдем мин и макс время
			МинДата = ТаблицаДанных[0][ИмяКолонкиДатаВремя];
			МаксДата = МинДата;
			Для каждого стр из ТаблицаДанных Цикл
				Если МинДата>стр[ИмяКолонкиДатаВремя] Тогда
					МинДата = стр[ИмяКолонкиДатаВремя];
				КонецЕсли;
				Если МаксДата<стр[ИмяКолонкиДатаВремя] Тогда
					МаксДата = стр[ИмяКолонкиДатаВремя];
				КонецЕсли;			
			КонецЦикла;
			// посчитаем числом
			Для каждого стр из ТаблицаДанных Цикл
				стр.ВремяЧислом = стр[ИмяКолонкиДатаВремя]-МинДата;
			КонецЦикла;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат 0;
КонецФункции

&НаКлиенте
Функция ЭтоДата(ДатаСтрокой) 
	
	// формат 2019-04-26T11:24:04
	Если Найти(ДатаСтрокой,"T") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,"-") Тогда
		Возврат Истина;
		// Формат 04/26/2019 11:24:49.150
	ИначеЕсли Найти(ДатаСтрокой,"/") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,".") И Найти(ДатаСтрокой," ") Тогда
		Возврат Истина;
	КонецЕсли;	
	
	Возврат Ложь;
	
КонецФункции

&НаКлиенте
Функция ПрочитатьДату(ДатаСтрокой)
	
	ДатаСобытия = Дата(1,1,1);
	
	// формат 2019-04-26T11:24:04
	Если Найти(ДатаСтрокой,"T") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,"-") Тогда
		Попытка
			ДатаСобытия = Дата(ДатаСтрокой);
		Исключение
		КонецПопытки;
	КонецЕсли;
	// Формат 04/26/2019 11:24:49.150
	Если НЕ ЗначениеЗаполнено(ДатаСобытия)
		И Найти(ДатаСтрокой,"T") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,"-") Тогда
		
		// Первая всегда дата
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"""","");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"T","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"-","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"/","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,":","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,".","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой," ","#");
		
		Попытка
			МассивЧастейДаты = СтрРазделить(ДатаСтрокой,"#",Ложь);
			Год = Число(МассивЧастейДаты[0]);
			Месяц = Число(МассивЧастейДаты[1]);
			День = Число(МассивЧастейДаты[2]);
			Час = Число(МассивЧастейДаты[3]);
			Минута = Число(МассивЧастейДаты[4]);
			Секунда = Число(МассивЧастейДаты[5]);
			ДатаСобытия = Дата(Год,Месяц,День,Час,Минута,Секунда);
			
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	// Формат 04/26/2019 11:24:49.150
	Если НЕ ЗначениеЗаполнено(ДатаСобытия)
		И Найти(ДатаСтрокой,"/") И Найти(ДатаСтрокой,":") И Найти(ДатаСтрокой,".") И Найти(ДатаСтрокой," ") Тогда
		
		// Первая всегда дата
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"""","");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,"/","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,":","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой,".","#");
		ДатаСтрокой = СтрЗаменить(ДатаСтрокой," ","#");
		
		Попытка
			МассивЧастейДаты = СтрРазделить(ДатаСтрокой,"#",Ложь);
			Год = Число(МассивЧастейДаты[2]);
			Месяц = Число(МассивЧастейДаты[0]);
			День = Число(МассивЧастейДаты[1]);
			Час = Число(МассивЧастейДаты[3]);
			Минута = Число(МассивЧастейДаты[4]);
			Секунда = Число(МассивЧастейДаты[5]);
			ДатаСобытия = Дата(Год,Месяц,День,Час,Минута,Секунда);
			
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат ДатаСобытия;
	
КонецФункции

&НаКлиенте
Процедура ПозиционироватьЧтениеНаСтрокуФайла(ЧтениеФайла, НомерСтроки)
	ТекНомерСтроки = 0;
	ТекСтрокаФайла = "";
	Пока ТекНомерСтроки < НомерСтроки 
		И ТекСтрокаФайла <> Неопределено Цикл
		ТекСтрокаФайла = ЧтениеФайла.ПрочитатьСтроку();
		ТекНомерСтроки = ТекНомерСтроки + 1;
	КонецЦикла; 
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьДанныеИзФайла(Команда)
	ТаблицаДанных.Очистить();
	РазобратьФайлВТаблицуCSV(ПутьКДанным);
	// обновим параметры выбора для данных
	ОбновитьПараметрыВыбораВходов();
КонецПроцедуры

&НаКлиенте
Функция СохранитьФайлВТаблицуCSV(ПутьКФайлу) Экспорт
	
	ИмяФайлаДляРазбора 	= ПутьКФайлу;  	
	
	ДатаНачалаЧтения = ТекущаяДата();
	
	Текст = Новый ЗаписьТекста(ИмяФайлаДляРазбора, КодировкаТекста.ANSI, Символы.ВК + Символы.ПС, Ложь,"");
	
	СтрокаТекста = "";
	// заголовки
	Для каждого колонка из КолонкиТаблицыДанных Цикл
		Если колонка.Заголовок="t" или колонка.Заголовок="№" Тогда
			Продолжить;
		КонецЕсли;
		СтрокаТекста = СтрокаТекста + ?(СтрокаТекста="","",",")+""""+колонка.Заголовок+"""";
	КонецЦикла;
	Текст.ЗаписатьСтроку(СтрокаТекста,Символы.ВК + Символы.ПС);
	
	// данные
	Для каждого стр из ТаблицаДанных Цикл
		СтрокаТекста = "";
		Для каждого колонка из КолонкиТаблицыДанных Цикл
			Если колонка.Заголовок="t" или колонка.Заголовок="№" Тогда
				Продолжить;
			КонецЕсли;
			СтрокаТекста = СтрокаТекста + ?(СтрокаТекста="","",",")+""""+XMLСтрока(стр[колонка.Имя])+"""";
		КонецЦикла;
		Текст.ЗаписатьСтроку(СтрокаТекста,Символы.ВК + Символы.ПС);
	КонецЦикла;
	
	Текст.Закрыть();
	
	Возврат 0;
КонецФункции


&НаКлиенте
Процедура СохранитьДанныеВФайл(Команда)
	// сохраним в CSV
	СохранитьФайлВТаблицуCSV(ПутьКДанным);	
КонецПроцедуры

#КонецОбласти


#Область РисуемГрафик

&НаКлиенте
Процедура СоздатьСвойстваКнопок()
	
	МассивКнопок = ПолучитьМассивИменКнопок();
	
	Для каждого кнопка из МассивКнопок Цикл
		МассивСинонимовСвойств = ПолучитьМассивСинонимовСвойств(кнопка);
		Для каждого синоним из МассивСинонимовСвойств Цикл
			стр_н= СвойстваКнопокРедактирования.Добавить();
			стр_н.Кнопка = кнопка;
			стр_н.Синоним = синоним;
			стр_н.Значение=0;
			Если синоним="t шаг" Тогда
				стр_н.Значение = 15;
			ИначеЕсли синоним="k" Тогда
				стр_н.Значение = 1;
			ИначеЕсли синоним="t кон." Тогда
				стр_н.Значение = ШиринаОкна;
			ИначеЕсли синоним="кластер" Тогда
				стр_н.Значение = "";
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	НажатаяКнопкаРедактирования = "Неопределено";
	УстановитьФильтрСвойствТаблицыРедактирования();
	РежимРедактированияГрафика = "Добавление";
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьМассивСинонимовСвойств(ИмяКнопки="")
	
	ТекстыСвойств = "t нач.
	|t кон.
	|h нач.
	|h кон.";
	
	Если ИмяКнопки="Фильтр" Тогда
		ТекстыСвойств = "t нач.
		|t кон.";
	ИначеЕсли ИмяКнопки="Линия" Тогда
		ТекстыСвойств = "t нач.
		|t кон.
		|h нач.";
	ИначеЕсли ИмяКнопки="БелыйШум" Тогда
		ТекстыСвойств = "t нач.
		|t кон.
		|h нач.
		|h кон.";
	ИначеЕсли ИмяКнопки="ПоднятьВверх" ИЛИ  ИмяКнопки="ОпуститьВниз" Тогда
		ТекстыСвойств = "t нач.
		|t кон.
		|h нач.";
	ИначеЕсли ИмяКнопки="СкачокВверх" ИЛИ ИмяКнопки="СкачокВниз" Тогда
		ТекстыСвойств = "t нач.
		|t кон.
		|h нач.";
	ИначеЕсли ИмяКнопки="Кластер" Тогда
		ТекстыСвойств = "t нач.
		|t кон.
		|кластер";
	КонецЕсли;
	
	МассивКнопок = СтрРазделить(ТекстыСвойств,Символы.ПС,Ложь);
	Возврат МассивКнопок;
	
КонецФункции

&НаКлиенте
Функция ПолучитьМассивИменКнопок()
	
	ТекстыКнопок = "ЛинейныйВозрастающий ЛинейныйУбывающий БелыйШум Фильтр 
	| СтупенькаВверх СтупенькаВниз НелинейноВозрастающий НелинейноУбывающий 
	| СкачокВверх СкачокВниз ПоднятьВверх ОпуститьВниз 
	| Линия Очистить Кластер ";
	ТекстыКнопок = СтрЗаменить(ТекстыКнопок,Символы.ПС,"");
	МассивКнопок = СтрРазделить(ТекстыКнопок," ",Ложь);
	Возврат МассивКнопок;
	
КонецФункции	

&НаКлиенте
Процедура НажатиеКнопкиРисунка(Элемент)
	
	МассивКнопок = ПолучитьМассивИменКнопок();
	ТипНажата = ТипРамкиЭлементаУправления.Вдавленная;
	ТипОжидание = ТипРамкиЭлементаУправления.Выпуклая;
	
	
	Для каждого стр из МассивКнопок Цикл
		Элементы[стр].Рамка  = Новый Рамка(ТипОжидание,2);
	КонецЦикла;
	
	Элемент.Рамка =  Новый Рамка(ТипНажата,2);
	НажатаяКнопкаРедактирования = Элемент.Имя;
	
	УстановитьФильтрСвойствТаблицыРедактирования();
	
	Если НЕ НажатаяКнопкаРедактирования="Кластер" Тогда
		Элементы.СвойстваКнопокРедактированияЗначение.РежимВыбораИзСписка = Ложь;
	КонецЕсли;
	
КонецПроцедуры


&НаКлиенте
Процедура СвойстваКнопокРедактированияПриАктивизацииСтроки(Элемент)
	
	ТекущиеДанные = Элементы.СвойстваКнопокРедактирования.ТекущиеДанные;
	
	Если НажатаяКнопкаРедактирования="Кластер" Тогда
		Если ТекущиеДанные.Синоним="кластер" Тогда
			Элементы.СвойстваКнопокРедактированияЗначение.РежимВыбораИзСписка = Истина;
			ОбновитьСписокВыбораКластераИзБазы("СвойстваКнопокРедактированияЗначение");
		Иначе
			Элементы.СвойстваКнопокРедактированияЗначение.РежимВыбораИзСписка = Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры


&НаКлиенте
Процедура УстановитьФильтрСвойствТаблицыРедактирования()
	
	// фильтр
	СтруктураОтбора = Новый Структура("Кнопка",НажатаяКнопкаРедактирования);
	ФиксОтбор = Новый ФиксированнаяСтруктура(СтруктураОтбора);		
	
	Элементы.СвойстваКнопокРедактирования.ОтборСтрок = ФиксОтбор;
	
КонецПроцедуры

&НаКлиенте
Процедура ПрименитьИзмененияРисунка(Команда)
	
	ОбработатьНажатуюКнопкуРедактора();	
	ПерерисоватьГрафикТочек1С();
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьНажатуюКнопкуРедактора()
	
	Кнопка = НажатаяКнопкаРедактирования;
	
	t_нач = ПолучитьЗначениеСвойства(Кнопка,"t нач.");
	t_кон = ПолучитьЗначениеСвойства(Кнопка,"t кон.");
	h_нач = ПолучитьЗначениеСвойства(Кнопка,"h нач.");
	h_кон = ПолучитьЗначениеСвойства(Кнопка,"h кон.");
	кластер = ПолучитьЗначениеСвойства(Кнопка,"кластер");
	
	//ШиринаОкна = t_кон - t_нач;
	ШагВремени = ШагОкна;
	
	// получим имя свойства
	Свойство = НайтиИмяВходаТаблицыДанных(РедактируемыйВход);
	
	
	Если Кнопка = "Линия" Тогда
		
		Если ШагВремени<=0  Тогда
			Сообщить("Установите шаг времени!");
			Возврат;
		КонецЕсли;
		
		ш = t_нач;
		Пока ш<=t_кон Цикл  
			
			стр_н = НайтиСоздатьТочкуТаблицы("ТаблицаДанных",ш);
			стр_н.ВремяЧислом = ш;
			стр_н[Свойство] = h_нач;
			ш=ш+ШагВремени;			
			
		КонецЦикла;
		
		
		// Очищаем в 0 в интервале
	ИначеЕсли НажатаяКнопкаРедактирования = "Очистить" Тогда		
		
		
		Для каждого стр из ТаблицаДанных Цикл
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			стр[Свойство] = 0;
			
		КонецЦикла;		
		
	ИначеЕсли НажатаяКнопкаРедактирования="ЛинейныйВозрастающий" 
		ИЛИ НажатаяКнопкаРедактирования="ЛинейныйУбывающий"  Тогда
		
		Если ШагВремени<=0  Тогда
			Сообщить("Установите шаг времени!");
			Возврат;
		КонецЕсли;
		
		alpa = (h_кон-h_нач)/(t_кон-t_нач);
		beta = h_нач - t_нач*alpa;
		
		ш = t_нач;
		Пока ш<=t_кон Цикл  
			
			стр_н = НайтиСоздатьТочкуТаблицы("ТаблицаДанных",ш);
			стр_н.ВремяЧислом = ш;
			Если РежимРедактированияГрафика="Замена" Тогда
				стр_н[Свойство] = alpa*ш+beta;
			Иначе
				стр_н[Свойство] = стр_н[Свойство]+alpa*ш+beta;
			КонецЕсли;
			ш=ш+ШагВремени;			
			
		КонецЦикла;
		
	ИначеЕсли НажатаяКнопкаРедактирования="БелыйШум" Тогда
		
		Если ШагВремени<=0  Тогда
			Сообщить("Установите шаг времени!");
			Возврат;
		КонецЕсли;
		
		
		ГСЧ = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
		
		ш = t_нач;
		Пока ш<=t_кон Цикл  
			
			Значение = ГСЧ.СлучайноеЧисло(h_нач*1000,h_кон*1000)/1000;
			
			стр_н = НайтиСоздатьТочкуТаблицы("ТаблицаДанных",ш);
			стр_н.ВремяЧислом = ш;
			Если РежимРедактированияГрафика="Замена" Тогда
				стр_н[Свойство] = Значение;
			Иначе
				стр_н[Свойство] = стр_н[Свойство]+Значение;
			КонецЕсли;
			ш=ш+ШагВремени;			
			
		КонецЦикла;
		
		// Усредним
	ИначеЕсли НажатаяКнопкаРедактирования="Фильтр" Тогда
		
		стр = Неопределено;
		стр1 = Неопределено;
		
		Для ш=0 по ТаблицаДанных.Количество()-1 Цикл
			стр = ТаблицаДанных[ш];
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			Если стр1=Неопределено Тогда
				стр1 = стр[Свойство];
			Иначе
				стр1 = ТаблицаДанных[ш-1];
				стр1[Свойство] = (стр1[Свойство]+стр[Свойство])/2;
			КонецЕсли;			
			
		КонецЦикла;
		
		// последняя точка
		Если (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
			Если ТаблицаДанных.Количество()>1 Тогда
				стр[Свойство]=(стр1[Свойство]+стр[Свойство])/2;
			КонецЕсли;
		КонецЕсли;
		// поднимим опустим
	ИначеЕсли НажатаяКнопкаРедактирования="ПоднятьВверх" ИЛИ 
		НажатаяКнопкаРедактирования="ОпуститьВниз" Тогда
		
		Для каждого стр из ТаблицаДанных Цикл
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			Если НажатаяКнопкаРедактирования="ПоднятьВверх" Тогда
				стр[Свойство] = стр[Свойство]+h_нач;
			Иначе
				стр[Свойство] = стр[Свойство]-h_нач;
			КонецЕсли;			
			
		КонецЦикла;	
		
	ИначеЕсли НажатаяКнопкаРедактирования="СкачокВверх" ИЛИ 
		НажатаяКнопкаРедактирования="СкачокВниз" Тогда
		
		Для каждого стр из ТаблицаДанных Цикл
			
			Если стр.ВремяЧислом=Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ (стр.ВремяЧислом>=t_нач И  стр.ВремяЧислом<=t_кон) Тогда
				Продолжить;
			КонецЕсли;
			
			Если НажатаяКнопкаРедактирования="СкачокВверх" Тогда
				стр[Свойство] = стр[Свойство]+h_нач;
			Иначе
				стр[Свойство] = стр[Свойство]-h_нач;
			КонецЕсли;
			
			Прервать;
			
		КонецЦикла;	
		
	ИначеЕсли Кнопка = "Кластер" Тогда
		
		ш = t_нач;
		Пока ш<=t_кон Цикл  
			
			стр_н = НайтиСоздатьТочкуТаблицы("ТаблицаДанных",ш);
			стр_н.ВремяЧислом = ш;
			стр_н[ИмяКолонкиКластер] = кластер;
			ш=ш+ШагВремени;			
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция НайтиСоздатьТочкуТаблицы(ИмяТаблицы,ВремяЧислом,СоздаватьНовый=Истина)
	
	мОтбор = Новый Структура("ВремяЧислом",ВремяЧислом);
	н_строки = ЭтаФорма[ИмяТаблицы].НайтиСтроки(мОтбор);
	
	Если н_строки.Количество()=0 Тогда
		Если СоздаватьНовый=Ложь Тогда
			Возврат Неопределено;
		КонецЕсли;
		стр_н =  ЭтаФорма[ИмяТаблицы].Добавить();
		// обнулим
		Для каждого стр из КолонкиТаблицыДанных Цикл
			Если стр_н[стр.Имя]=Неопределено Тогда
				стр_н[стр.Имя] = 0;
			КонецЕсли;
		КонецЦикла;
		Возврат стр_н;
	Иначе
		Возврат н_строки[0];
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция НайтиСоздатьТочкуТаблицыПоДатеСобытия(ИмяТаблицы,ДатаСобытия,СоздаватьНовый=Истина)
	
	//мОтбор = Новый Структура("ДатаВремя",ДатаСобытия);
	мОтбор = Новый Структура(ИмяКолонкиДатаВремя,ДатаСобытия);
	н_строки = ЭтаФорма[ИмяТаблицы].НайтиСтроки(мОтбор);
	
	Если н_строки.Количество()=0 Тогда
		Если СоздаватьНовый=Ложь Тогда
			Возврат Неопределено;
		КонецЕсли;
		стр_н =  ЭтаФорма[ИмяТаблицы].Добавить();
		// обнулим
		Для каждого стр из КолонкиТаблицыДанных Цикл
			Если стр_н[стр.Имя]=Неопределено Тогда
				стр_н[стр.Имя] = 0;
			КонецЕсли;
		КонецЦикла;
		Возврат стр_н;
	Иначе
		Возврат н_строки[0];
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция НайтиИмяВходаТаблицыДанных(Заголовок)
	Свойство = "";
	
	Если КолонкиТаблицыДанных=НЕопределено Тогда
		Возврат Свойство;
	КонецЕсли;
	
	Для каждого стр из КолонкиТаблицыДанных Цикл
		
		Если Заголовок=стр.Имя Тогда
			Свойство = Заголовок;
			Прервать;
		КонецЕсли;
		
		Если Заголовок=стр.Заголовок Тогда
			Свойство = стр.Имя;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Свойство;
КонецФункции

&НаСервере
Функция НайтиИмяВходаТаблицыДанныхСервер(Заголовок)
	Свойство = "";
	
	Если КолонкиТаблицыДанных=НЕопределено Тогда
		Возврат Свойство;
	КонецЕсли;
	
	Для каждого стр из КолонкиТаблицыДанных Цикл
		
		Если Заголовок=стр.Имя Тогда
			Свойство = Заголовок;
			Прервать;
		КонецЕсли;
		
		Если Заголовок=стр.Заголовок Тогда
			Свойство = стр.Имя;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Свойство;
КонецФункции

&НаКлиенте
Функция НайтиЗаголовокВходаТаблицыДанных(Имя)
	ЗаголовокСвойства = "";
	
	Если КолонкиТаблицыДанных=НЕопределено Тогда
		Возврат ЗаголовокСвойства;
	КонецЕсли;
	
	Для каждого стр из КолонкиТаблицыДанных Цикл
		
		Если Имя=стр.Имя Тогда
			ЗаголовокСвойства = стр.Заголовок;
			Прервать;
		КонецЕсли;
		
		Если Имя=стр.Заголовок Тогда
			ЗаголовокСвойства = стр.Заголовок;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ЗаголовокСвойства;
КонецФункции

&НаСервере
Функция НайтиИмяЗаголовкаТаблицыДанных(Свойство)
	Заголовок = "";
	
	Если КолонкиТаблицыДанных=НЕопределено Тогда
		Возврат Заголовок;
	КонецЕсли;
	
	Для каждого стр из КолонкиТаблицыДанных Цикл
		
		Если Свойство=стр.Имя Тогда
			Заголовок = стр.Заголовок;
			Прервать;
		КонецЕсли;
		
		Если Свойство=стр.Заголовок Тогда
			Заголовок = Свойство;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Заголовок;
КонецФункции	

&НаКлиенте
Функция ПолучитьЗначениеСвойства(Кнопка,Синоним)
	
	мОтбор = Новый Структура("Кнопка,Синоним",Кнопка,Синоним);
	н_строки = СвойстваКнопокРедактирования.НайтиСтроки(мОтбор);
	
	Если н_строки.Количество()=0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат н_строки[0].Значение;
	
КонецФункции

&НаКлиенте
Процедура УстановитьЗначениеСвойства(Кнопка,Синоним,Значение)
	
	мОтбор = Новый Структура("Кнопка,Синоним",Кнопка,Синоним);
	н_строки = СвойстваКнопокРедактирования.НайтиСтроки(мОтбор);
	
	н_строки[0].Значение = Значение;
	
КонецПроцедуры


&НаКлиенте
Процедура ПерерисоватьГрафикТочек1С()
	
	ИмяВхода0 = "ВремяЧислом";
	ИмяВхода1 = НайтиИмяВходаТаблицыДанных(РедактируемыйВход); 
	Заголовок1 = НайтиЗаголовокВходаТаблицыДанных(ИмяВхода1);
	
	ДиаграммаРедактора.Очистить();
	ДиаграммаРедактора.ТипДиаграммы=ТипДиаграммы.График;
	
	Если ЗначениеЗаполнено(РедактируемыйВход) Тогда
		СерияОкно = ДиаграммаРедактора.УстановитьСерию(Заголовок1);
		
		Для каждого стр из ТаблицаДанных Цикл
			ТочкаДиаграммы = ДиаграммаРедактора.УстановитьТочку(стр[ИмяВхода0]);
			// добавим значение	
			ДиаграммаРедактора.УстановитьЗначение(ТочкаДиаграммы, СерияОкно, стр[ИмяВхода1]);
		КонецЦикла;
	КонецЕсли;
	
	// отображаем другие
	Для каждого вход из ТаблицаВходов Цикл
		Если вход.Сигнал=Заголовок1 Тогда
			Продолжить;
		КонецЕсли;
		
		Если вход.Выбрана=Ложь Тогда
			Продолжить;
		КонецЕсли;
		
		СерияОкно = ДиаграммаРедактора.УстановитьСерию(вход.Сигнал);
		ИмяВхода2 = НайтиИмяВходаТаблицыДанных(вход.Сигнал); 
		
		Для каждого стр из ТаблицаДанных Цикл
			ТочкаДиаграммы = ДиаграммаРедактора.УстановитьТочку(стр[ИмяВхода0]);
			// добавим значение	
			ДиаграммаРедактора.УстановитьЗначение(ТочкаДиаграммы, СерияОкно, стр[ИмяВхода2]);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура ПерерисоватьГрафикТочекHTML()
	
	
	ПолеChart = Элементы.ГрафикHTML.Документ.getElementById("myDiv");
	
	Если ПолеChart=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ИмяВхода0 = "ВремяЧислом";
	ИмяВхода1 = НайтиИмяВходаТаблицыДанных(РедактируемыйВход); 
	
	array = "
	|var points = {
	|mode: 'lines',
	|type: 'scatter',
	|name: 'Points',
	|marker: { size: 8 },";
	
	
	// точки
	x_str = "";
	y_str = "";
	
	
	Для каждого стр из ТаблицаДанных Цикл
		x_str = x_str +?(x_str="","",",")+ XMLСтрока(стр[ИмяВхода0]);
		y_str = y_str +?(y_str="","",",")+ XMLСтрока(стр[ИмяВхода1]);		
	КонецЦикла;
	
	array = array+"
	|x: ["+x_str+"],
	|y: ["+y_str+"]";
	array = array+"
	|};";
	
	
	array = array+ "
	|var som = {
	|mode: 'markers',
	|type: 'scatter',
	|name: 'Clusters',
	|marker: { size: 12 },
	|x: [0],
	|y: [0]
	|};";
	
	
	
	JS=array+"var data = [ points, som ];";	
	
	
	delement = Элементы.ГрафикHTML.Документ.getElementById("d");
	delement.value = JS;
	
	element = Элементы.ГрафикHTML.Документ.getElementById("t");
	element.onClick();	
	
	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьГрафикРедактора(Команда)
	ПерерисоватьГрафикТочек1С();
КонецПроцедуры



#КонецОбласти


#Область ПутьКФайлу


&НаКлиенте
Процедура ПутьКДаннымНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие); 
	Диалог.Заголовок = "Выберите файл"; 
	Если ЗначениеЗаполнено(ПутьКДанным) Тогда
		Диалог.Каталог = ПолучитьКаталогПоПутиФайла(ПутьКДанным);
	КонецЕсли;
	Диалог.ПолноеИмяФайла = ""; 
	Фильтр = "CSV-файл (*.csv)|*.csv"; 
	Диалог.Фильтр = Фильтр; 
	Диалог.МножественныйВыбор = Ложь; 
	ВыборФайлаОткрытияФайла = Новый ОписаниеОповещения("ВыборФайлаОткрытияФайла",ЭтотОбъект,Новый Структура("ИмяРеквизита","ПутьКДанным"));
	Диалог.Показать(ВыборФайлаОткрытияФайла);
КонецПроцедуры

&НаКлиенте
Процедура ПутьКНейроннаяСетьНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие); 
	Диалог.Заголовок = "Выберите файл"; 
	Если ЗначениеЗаполнено(ПутьКНейроннаяСеть) Тогда
		Диалог.Каталог = ПолучитьКаталогПоПутиФайла(ПутьКНейроннаяСеть);
	КонецЕсли;
	Диалог.ПолноеИмяФайла = ""; 
	Фильтр = "XML-файл (*.xml)|*.xml"; 
	Диалог.Фильтр = Фильтр; 
	Диалог.МножественныйВыбор = Ложь; 
	ВыборФайлаОткрытияФайла = Новый ОписаниеОповещения("ВыборФайлаОткрытияФайла",ЭтотОбъект,Новый Структура("ИмяРеквизита","ПутьКНейроннаяСеть"));
	Диалог.Показать(ВыборФайлаОткрытияФайла);
КонецПроцедуры


&НаКлиенте
Функция  ПолучитьКаталогПоПутиФайла(Знач ПутьКФайлу)
	Файл = Новый Файл(ПутьКФайлу);
	Возврат Файл.Путь;	
КонецФункции

&НаКлиенте
Процедура ВыборФайлаОткрытияФайла(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	
	Если ВыбранныеФайлы <> Неопределено И ВыбранныеФайлы.Количество() > 0 Тогда
		ЭтаФорма[ДополнительныеПараметры.ИмяРеквизита] = ВыбранныеФайлы[0]; 
	КонецЕсли; 
	
КонецПроцедуры


#КонецОбласти


&НаКлиенте
Процедура ОбновитьПараметрыВыбораВходов()
	
	Элементы.РедактируемыйВход.СписокВыбора.Очистить();
	Для  каждого стр из КолонкиТаблицыДанных Цикл
		Если стр.Заголовок="t" ИЛИ стр.Заголовок="№" ИЛИ стр.Заголовок="date" Тогда
			Продолжить;
		КонецЕсли;
		Элементы.РедактируемыйВход.СписокВыбора.Добавить(стр.Имя,стр.Заголовок);
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура ТестСетиПриИзменении(Элемент)
	Элементы.ГруппаТестовыеДанные.Видимость = ТестСети;
	Элементы.ГруппаРабочиеДанные.Видимость = НЕ ТестСети;
КонецПроцедуры

&НаКлиенте
Процедура СформироватьТаблицуДанных(Команда)
	
	// Сформируем таблицу, данных
	Колонки = Новый Массив;
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Дата"));
	МассивТипов.Добавить(Тип("Булево"));
	КС = Новый КвалификаторыСтроки(20);
	КЧ = Новый КвалификаторыЧисла(20,10);
	КЧЦ = Новый КвалификаторыЧисла(20,0);
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов, , ,КЧ, КС);
	ОписаниеСтрока = Новый ОписаниеТипов("Строка", , ,КЧ, КС);
	ОписаниеЧисло = Новый ОписаниеТипов("Число", , ,КЧ);	
	ОписаниеЧислоЦелое = Новый ОписаниеТипов("Число", , ,КЧЦ);	
	ОписаниеДата = Новый ОписаниеТипов("Дата", , ,КЧЦ);	
	
	Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","НомерСтроки",ОписаниеЧислоЦелое,10,"№",Неопределено,Ложь,"Число",Истина));
	Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","ВремяЧислом",ОписаниеЧисло,10,"t",Неопределено,Ложь,"Число",Истина));
	Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","ДатаВремя",ОписаниеДата,10,"date",Неопределено,Ложь,"Дата",Истина));	
	Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость","Кластер",ОписаниеСтрока,10,"claster",Неопределено,Ложь,"Строка",Истина));	
	ИмяКолонкиДатаВремя = "ДатаВремя";
	ИмяКолонкиКластер = "Кластер";
	
	ш=0;
	Для каждого стр из ТаблицаВходов Цикл
		ИмяКолонки = "Свойство_"+XMLСтрока(ш);
		стр.Номер = ш;
		Колонки.Добавить(Новый Структура("Имя,ТипЗначения,Ширина,Заголовок,ИмяСледующегоЭлемента,ТолькоПросмотр,ТипСтрокой,Видимость",ИмяКолонки,ОписаниеЧисло,10,стр.Сигнал,Неопределено,Ложь,"ОписаниеТипов",Истина));	
		ш=ш+1;
	КонецЦикла;
	
	КолонкиТаблицыДанных.Очистить();
	Для каждого стр из Колонки Цикл
		стр_н = КолонкиТаблицыДанных.Добавить();
		ЗаполнитьЗначенияСвойств(стр_н,стр);
	КонецЦикла;
	
	
	СоздатьДинамическиеКолонкиТаблицы("ТаблицаДанных",Колонки,СтарыеКолонки);
	
	СтарыеКолонки = Колонки;
	
	ОбновитьПараметрыВыбораВходов();
	
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаВходовПриИзменении(Элемент)
	ОбновитьПараметрыВыбораВходов();
КонецПроцедуры

&НаКлиенте
Процедура ГенерироватьТаблицу(Команда)
	ш=0;
	ж=0;
	Если ШиринаОкна<0 Тогда
		ШиринаОкна=-ШиринаОкна;
	КонецЕсли;
	Если ШагОкна<0 Тогда
		ШагОкна=-ШагОкна;
	КонецЕсли;
	Пока ш<ШиринаОкна Цикл
		
		стр_н = ТаблицаДанных.Добавить();
		стр_н.НомерСтроки = ж;
		стр_н.ВремяЧислом = ш;
		стр_н[ИмяКолонкиДатаВремя] = НачалоОкна+ш;
		Для каждого стр Из КолонкиТаблицыДанных Цикл
			Если стр.Имя="НомерСтроки" ИЛИ стр.Имя="ВремяЧислом" ИЛИ стр.Имя=ИмяКолонкиДатаВремя  Тогда
				Продолжить;
			КонецЕсли;
			стр_н[стр.Имя] = 0;
		КонецЦикла;		
	
		ш=ш+ШагОкна;
		ж=ж+1;
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура РедактируемыйВходПриИзменении(Элемент)
	ПерерисоватьГрафикТочек1С();
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаВходов1ПриИзменении(Элемент)
	ПерерисоватьГрафикТочек1С();
КонецПроцедуры

&НаКлиенте
Процедура ДиаграммаРедактораПриАктивизации(Элемент)
	Если НажатаяКнопкаРедактирования="Неопределено" Тогда
		Возврат;
	КонецЕсли;
	Данные = Элемент.ПолучитьВыделенныеЭлементы();
	t_нач = 0;
	t_кон = 0;
	Если Данные.Количество()>0 Тогда
		t_нач = Данные[0].Точка.Значение;
		t_кон = Данные[0].Точка.Значение;
	КонецЕсли;
	Для каждого зн из Данные Цикл 
		Если зн.Точка.Значение>t_кон Тогда
			t_кон = зн.Точка.Значение;
		КонецЕсли;
		Если зн.Точка.Значение<t_нач Тогда
			t_нач = зн.Точка.Значение;
		КонецЕсли;
	КонецЦикла;
	Если t_кон=t_нач Тогда
		Возврат;
	КонецЕсли;
	// изменим координаты выделения интервала
	Кнопка = НажатаяКнопкаРедактирования;	
	УстановитьЗначениеСвойства(Кнопка,"t нач.",t_нач);
	УстановитьЗначениеСвойства(Кнопка,"t кон.",t_кон);
КонецПроцедуры

&НаКлиенте
Процедура ДиаграммаРедактораВыбор(Элемент, ЗначениеДиаграммы, СтандартнаяОбработка)
	// Вставить содержимое обработчика.
КонецПроцедуры

#Область ДанныеИзБазы

&НаКлиенте
Процедура ОбновитьДанныеИзБазы(Команда)
	ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
КонецПроцедуры


&НаКлиенте
Процедура ОбновитьГрафикИсторииКлиент(ДатаНачала,Интервал)
	
	Если Интервал=0 Тогда
		Интервал = 600;
	КонецЕсли;
	
	Если ДатаНачала=Дата(1,1,1) Тогда
		ДатаНачала = ТекущаяДата()-Интервал;
	КонецЕсли;
	
	ДатаОкончания = ДатаНачала+Интервал;
	
	КешПараметров.Вставить("ПредИнтервалНачало",КешПараметров.Получить("ИнтервалНачало"));
	КешПараметров.Вставить("ПредИнтервалОкончание",КешПараметров.Получить("ИнтервалОкончание"));
	
	КешПараметров.Вставить("ИнтервалНачало",ДатаНачала);
	КешПараметров.Вставить("ИнтервалОкончание",ДатаОкончания);
	
	ОбновитьГрафикИсторииСервер(НейроннаяСетьКартаКохонена,ДатаНачала,ДатаОкончания);
	
КонецПроцедуры

&НаСервере
Процедура ОбновитьГрафикИсторииСервер(НейроннаяСеть, ДатаНачала,ДатаОкончания)
	
	мОтбор = Новый  Структура("Выбрана",Истина);
	ТаблицаЗамеров = ТаблицаИсточниковИзБазы.Выгрузить(ТаблицаИсточниковИзБазы.НайтиСтроки(мОтбор),);
	
	ДиаграммаДанныхИзБазы.Очистить();
	ДиаграммаДанныхИзБазы = новый Диаграмма;
	ДиаграммаДанныхИзБазы.ТипДиаграммы=ТипДиаграммы.График;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	ТЗ.Замер КАК Замер,
	|	ТЗ.Свойство КАК Свойство
	|ПОМЕСТИТЬ ВтТЗ
	|ИЗ
	|	&ТЗ КАК ТЗ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Т.Ссылка.Владелец КАК Замер,
	|	Т.Свойство КАК Свойство,
	|	Т.ЗначениеЧисло КАК ЗначениеЧисло,
	|	Т.Ссылка.ДатаСобытия КАК ДатаСобытия
	|ИЗ
	|	Справочник.СобытияЗамера.КлючевыеСвойства КАК Т
	|ГДЕ
	|	(Т.Ссылка.Владелец, Т.Свойство) В
	|			(ВЫБРАТЬ
	|				Т.Замер,
	|				Т.Свойство
	|			ИЗ
	|				ВтТЗ КАК Т)
	|	И Т.Ссылка.НомерСтрокиФайла = 0
	|	И Т.Ссылка.ДатаСобытия МЕЖДУ &ДатаНачала И &ДатаОкончания
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДатаСобытия";	
	Запрос.УстановитьПараметр("ТЗ", ТаблицаЗамеров);
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачала);
	Запрос.УстановитьПараметр("ДатаОкончания", ДатаОкончания);
	// кластер
	Запрос.УстановитьПараметр("Ключ", key);
	Запрос.УстановитьПараметр("СинонимКлюча", "key");
	
	
	КешСерий = Новый Соответствие;
	КешКлючей = Новый Соответствие;
	МассивКлючей = Новый Массив;
	Для каждого стр из ТаблицаЗамеров Цикл
		МассивКлючей.Добавить(стр.Ключ);
		Серия = ДиаграммаДанныхИзБазы.УстановитьСерию(стр.Ключ);
		КешСерий.Вставить(стр.Ключ,Серия);
		КешКлючей.Вставить(Строка(стр.Свойство)+"/"+Строка(стр.Замер),стр.Ключ);
	КонецЦикла;
	
	ТаблицаДанныхИзБазы =  Запрос.Выполнить().Выгрузить();
	
	КешПредыдущих = Новый Соответствие;
	ПредыдущаяДатаСобытия = Неопределено;
	Если ТаблицаДанныхИзБазы.Количество()>0 Тогда
		ПредыдущаяДатаСобытия = ТаблицаДанныхИзБазы[0].ДатаСобытия - Секунда(ТаблицаДанныхИзБазы[0].ДатаСобытия);
	КонецЕсли;
	
	МассивНомрированныйИзБазы = Новый Массив;
	СтруктураДанных = Новый Соответствие();
	ПредыдущаяСтруктураДанных = Новый Соответствие();
	КлючейПоДатаСобытия = 0;
	
	
	Для каждого стр_данных из ТаблицаДанныхИзБазы Цикл
		
		// округлим до минут
		ДатаСобытия = стр_данных.ДатаСобытия - Секунда(стр_данных.ДатаСобытия);
		
		ОбновитьГрафикИсторииКлиентФрагмент(ДатаСобытия, КлючейПоДатаСобытия, МассивКлючей, МассивНомрированныйИзБазы, ПредыдущаяДатаСобытия, ПредыдущаяСтруктураДанных, СтруктураДанных);
		
		Ключ = КешКлючей.Получить(Строка(стр_данных.Свойство)+"/"+Строка(стр_данных.Замер));
		СтруктураДанных.Вставить(Ключ,стр_данных.ЗначениеЧисло);
		КлючейПоДатаСобытия = КлючейПоДатаСобытия+1;
		
	КонецЦикла;
	
	
	ОбновитьГрафикИсторииКлиентФрагмент(Неопределено, КлючейПоДатаСобытия, МассивКлючей, МассивНомрированныйИзБазы, ПредыдущаяДатаСобытия, ПредыдущаяСтруктураДанных, СтруктураДанных);
	
	// если первый из элементов пустой, тогда найдем последующий
	МассивПустых = новый Массив;
	ПрерватьЦикл = Ложь;
	Для каждого стр из МассивНомрированныйИзБазы Цикл
		
		ЕстьПустые = Ложь;
		
		Если ПрерватьЦикл = Истина Тогда			
			Если МассивПустых.Количество()>0 Тогда
				Для каждого стр_пуст из МассивПустых Цикл
					Для каждого стр_данных из стр_пуст.СтруктураДанных Цикл
						Если стр_данных.Значение=Неопределено Тогда
							стр_пуст.СтруктураДанных.Вставить(стр_данных.Ключ,стр.СтруктураДанных.Получить(стр_данных.Ключ));
						КонецЕсли;
					КонецЦикла;					
				КонецЦикла;
			КонецЕсли;			
			Прервать;
		КонецЕсли;

			
		Для каждого стр_данных из стр.СтруктураДанных Цикл
			Если стр_данных.Значение=Неопределено Тогда
				МассивПустых.Добавить(стр);
				ЕстьПустые=Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если ЕстьПустые=Ложь Тогда 
			ПрерватьЦикл=Истина;			
		КонецЕсли;
		
	КонецЦикла;

	
	Для каждого стр из МассивНомрированныйИзБазы Цикл
		
		Для каждого стр_дан из стр.СтруктураДанных Цикл
			
			// округлим до минут
			ДатаСобытия = стр.ДатаСобытия - Секунда(стр.ДатаСобытия);
			Ключ = стр_дан.Ключ;
			
			СерияОкно = КешСерий.Получить(Ключ);
			Если НЕ СерияОкно=Неопределено Тогда
				ТочкаДиаграммы = ДиаграммаДанныхИзБазы.УстановитьТочку(ДатаСобытия);
				// добавим значение	
				ДиаграммаДанныхИзБазы.УстановитьЗначение(ТочкаДиаграммы, СерияОкно, стр_дан.Значение);
			КонецЕсли;
			
		КонецЦикла;		
		
	КонецЦикла;
	
	Если НЕ НейроннаяСеть=Неопределено Тогда
		Если НЕ НаложитьМодельНаГрафикИзБазы="НеИспользовать" Тогда
			ПолучитьОценкуМодели(НейроннаяСеть,МассивНомрированныйИзБазы);
		КонецЕсли;
	КонецЕсли;
	
	АдресХранилищаДанныхИзБазы = ПоместитьВоВременноеХранилище(МассивНомрированныйИзБазы,ЭтаФорма.УникальныйИдентификатор);	
	
	Если НЕ НейроннаяСеть=Неопределено И
		НЕ НаложитьМодельНаГрафикИзБазы="НеИспользовать" Тогда
		Если НаложитьМодельНаГрафикИзБазы="ТолькоАномалии" ИЛИ НаложитьМодельНаГрафикИзБазы="Все" Тогда
			СерияОценка = ДиаграммаДанныхИзБазы.УстановитьСерию("Оценка");
		КонецЕсли;
		ИмяКластера = Неопределено;
		Интервал = Неопределено;
		ш=0;
		Для каждого стр из МассивНомрированныйИзБазы Цикл
			
			Если НаложитьМодельНаГрафикИзБазы="ТолькоАномалии" ИЛИ НаложитьМодельНаГрафикИзБазы="Все" Тогда
				ДатаСобытия = стр.ДатаСобытия - Секунда(стр.ДатаСобытия);
				ТочкаДиаграммы = ДиаграммаДанныхИзБазы.УстановитьТочку(ДатаСобытия);			
				// добавим значение	
				ДиаграммаДанныхИзБазы.УстановитьЗначение(ТочкаДиаграммы, СерияОценка, стр.СтруктураДанных.Получить("Оценка"));
			КонецЕсли;
			
			Если НаложитьМодельНаГрафикИзБазы="ТолькоАварии" ИЛИ НаложитьМодельНаГрафикИзБазы="Все" Тогда
				Если НЕ ИмяКластера=стр.СтруктураДанных.Получить("Кластер") Тогда
					Если стр.СтруктураДанных.Получить("Кластер")="Авария"Тогда
						Интервал = ДиаграммаДанныхИзБазы.ИнформационныеИнтервалыТочек.Добавить();
						Интервал.Начало = ДиаграммаДанныхИзБазы.Точки[ш];
						Интервал.Цвет = Новый Цвет(255, 200, 200);	
						Интервал.ПроцентПолупрозрачности = 60;
						//Интервал.ТекстПодписи = "Авария";	
					Иначе
						Если НЕ Интервал=Неопределено И ИмяКластера="Авария" Тогда
							Интервал.Конец = ДиаграммаДанныхИзБазы.Точки[ш];
						КонецЕсли;
					КонецЕсли;
					ИмяКластера=стр.СтруктураДанных.Получить("Кластер");
				КонецЕсли;
			КонецЕсли;
			ш=ш+1;
		КонецЦикла;
		
		Если НаложитьМодельНаГрафикИзБазы="ТолькоАварии" ИЛИ НаложитьМодельНаГрафикИзБазы="Все" Тогда
			Если Интервал.Конец=Неопределено Тогда
				Если НЕ Интервал=Неопределено И ИмяКластера="Авария" Тогда
					Интервал.Конец = ДиаграммаДанныхИзБазы.Точки[МассивНомрированныйИзБазы.ВГраница()];
				КонецЕсли;
			КонецЕсли;			
		КонецЕсли;			
		
		
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура ПолучитьОценкуМодели(НейроннаяСеть,МассивНомрированныйИзБазы)
	
	ш=0;
	Для каждого стр из МассивНомрированныйИзБазы Цикл
		Вектор = Новый Массив;
		ш=ш+1;
		
		// берем только первые входы
		Для к=0 по НейроннаяСеть.ЧислоВходов-1 Цикл
			Значение = стр.СтруктураДанных.Получить(ТаблицаИсточниковИзБазы[к].Ключ);
			Вектор.Добавить(Новый Структура("Значение",Значение));		
		КонецЦикла;
		
		НейронПобедитель = ПолучитьНейронПобедитель(НейроннаяСеть,Вектор);
		Нейрон = НейроннаяСеть.Нейроны[НейронПобедитель.ПозВысота][НейронПобедитель.ПозШирина];
		стр.СтруктураДанных.Вставить("Оценка",НейронПобедитель.Дистанция);
		стр.СтруктураДанных.Вставить("Нейрон",Нейрон.Имя);
		стр.СтруктураДанных.Вставить("Кластер",Нейрон.Кластер);
		
	КонецЦикла;	
	
	
КонецПроцедуры

&НаСервере
Процедура ОбновитьГрафикИсторииКлиентФрагмент(Знач ДатаСобытия, КлючейПоДатаСобытия, Знач МассивКлючей, Знач МассивНомрированный, ПредыдущаяДатаСобытия, ПредыдущаяСтруктураДанных, СтруктураДанных)
	
	Перем стр;
	
	Если НЕ ПредыдущаяДатаСобытия = ДатаСобытия Тогда
		МассивНомрированный.Добавить(Новый Структура("ДатаСобытия,СтруктураДанных",ПредыдущаяДатаСобытия,СтруктураДанных));
		ПредыдущаяДатаСобытия = ДатаСобытия;
		//проставим если не было значений по свойству
		Если КлючейПоДатаСобытия<МассивКлючей.Количество() Тогда
			Для каждого стр из МассивКлючей Цикл 
				Если СтруктураДанных.Получить(стр)=Неопределено Тогда
					СтруктураДанных.Вставить(стр,ПредыдущаяСтруктураДанных.Получить(стр));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		ПредыдущаяСтруктураДанных = СтруктураДанных;			
		СтруктураДанных = Новый Соответствие();
		КлючейПоДатаСобытия = 0;
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Процедура ТаблицаИсточниковИзБазыВыбранаПриИзменении(Элемент)
	ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
КонецПроцедуры

&НаКлиенте
Процедура ГотовыеВариантыИнтервалИзБазыПриИзменении(Элемент)
	Если ГотовыеВариантыИнтервалИзБазы=0 Тогда
		Элементы.ИнтервалИзБазы.Видимость=Истина;
	Иначе
		ИнтервалИзБазы = ГотовыеВариантыИнтервалИзБазы;
		Элементы.ИнтервалИзБазы.Видимость=Ложь;
		ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
	КонецЕсли;	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьВидимость()
	Если ГотовыеВариантыИнтервалИзБазы=0 Тогда
		Элементы.ИнтервалИзБазы.Видимость=Истина;
	Иначе
		Элементы.ИнтервалИзБазы.Видимость=Ложь;
	КонецЕсли;	
КонецПроцедуры


&НаКлиенте
Процедура БыстрыйСкроллОкнаПриИзменении(Элемент)
	ДатаНачалаИзБазы = ДатаНачалаИзБазы+БыстрыйСкроллОкна;
	ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
	БыстрыйСкроллОкна = 0;
КонецПроцедуры

&НаКлиенте
Процедура ДатаНачалаИзБазыПриИзменении(Элемент)
	ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
КонецПроцедуры

&НаКлиенте
Процедура ДиаграммаДанныхИзБазыПриАктивизации(Элемент)
	Данные = Элемент.ПолучитьВыделенныеЭлементы();
	t_нач = 0;
	t_кон = 0;
	Если Данные.Количество()>0 Тогда
		t_нач = Данные[0].Точка.Значение;
		t_кон = Данные[0].Точка.Значение;
	КонецЕсли;
	Для каждого зн из Данные Цикл 
		Если зн.Точка.Значение>t_кон Тогда
			t_кон = зн.Точка.Значение;
		КонецЕсли;
		Если зн.Точка.Значение<t_нач Тогда
			t_нач = зн.Точка.Значение;
		КонецЕсли;
	КонецЦикла;
	ИнтервалНачало = t_нач;
	ИнтервалОкончание = t_кон;
КонецПроцедуры

&НаКлиенте
Процедура ДобавитьВТаблицуДанных(Команда)
	
	Если НЕ ЭтоАдресВременногоХранилища(АдресХранилищаДанныхИзБазы) Тогда
		Возврат;
	КонецЕсли;
	
	МассивНомрированныйИзБазы = ПолучитьИзВременногоХранилища(АдресХранилищаДанныхИзБазы);
	
	
	Если МассивНомрированныйИзБазы=Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	КешСвойств = Новый Соответствие;
	Для каждого стр из ТаблицаИсточниковИзБазы Цикл
		КешСвойств.Вставить(стр.Ключ,НайтиИмяВходаТаблицыДанных(стр.Ключ));
	КонецЦикла;
	
	Для каждого стр из МассивНомрированныйИзБазы Цикл
		
		Если стр.ДатаСобытия<ИнтервалНачало ИЛИ стр.ДатаСобытия>ИнтервалОкончание Тогда
			Продолжить;
		КонецЕсли;
		
			стр_н = НайтиСоздатьТочкуТаблицыПоДатеСобытия("ТаблицаДанных",стр.ДатаСобытия);
			стр_н[ИмяКолонкиДатаВремя] = стр.ДатаСобытия; 
			стр_н.ВремяЧислом = стр.ДатаСобытия-НачалоДня(стр.ДатаСобытия);
			стр_н[ИмяКолонкиКластер]=КластерИзБазы;
			Для каждого св из стр.СтруктураДанных Цикл
				Свойство = КешСвойств.Получить(св.Ключ);
				Если НЕ ЗначениеЗаполнено(Свойство) Тогда
					Продолжить;
				КонецЕсли;
				стр_н[Свойство] = св.Значение;
			КонецЦикла;
		
		
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаИсточниковИзБазыПриИзменении(Элемент)
	Для каждого стр из ТаблицаИсточниковИзБазы Цикл
		Если НЕ ЗначениеЗаполнено(стр.Ключ) 
			И ЗначениеЗаполнено(стр.Свойство)
			И ЗначениеЗаполнено(стр.Замер) Тогда
			стр.Ключ = Строка(стр.Свойство)+" ("+Строка(стр.Замер)+")";
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура УпорядочитьПоДате(Команда)
	// Вставить содержимое обработчика.
КонецПроцедуры

&НаКлиенте
Процедура УстановитьШиринуОкнаПоВыбранномуИнтервалу(Команда)
	Если НЕ ЗначениеЗаполнено(ИнтервалНачало) ИЛИ НЕ ЗначениеЗаполнено(ИнтервалОкончание) Тогда
		Возврат;
	КонецЕсли;		
	ДатаНачалаИзБазы=ИнтервалНачало-Секунда(ИнтервалНачало);
	ИнтервалИзБазы=(ИнтервалОкончание-Секунда(ИнтервалОкончание))-ДатаНачалаИзБазы;
	ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
	ГотовыеВариантыИнтервалИзБазы=0;
	ГотовыеВариантыИнтервалИзБазыПриИзменении(Неопределено);
КонецПроцедуры

&НаКлиенте                      
Процедура ОбновитьСписокВыбораКластераИзБазы(ИмяЭлемента)
	Элементы[ИмяЭлемента].СписокВыбора.Очистить();
	Элементы[ИмяЭлемента].СписокВыбора.Добавить("","<неопределено>");
	Для Каждого стр из ТаблицаОписанияКластеров Цикл
		Элементы[ИмяЭлемента].СписокВыбора.Добавить(стр.Кластер);	
	КонецЦикла;
КонецПроцедуры	

&НаКлиенте
Процедура ТаблицаЦветовКластеровПриИзменении(Элемент)
	ОбновитьСписокВыбораКластераИзБазы("КластерИзБазы");
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаЦветовКластеров1ПриИзменении(Элемент)
	ОбновитьСписокВыбораКластераИзБазы("КластерИзБазы");
КонецПроцедуры

&НаКлиенте
Процедура НавигацияПоВремениПриИзменении(Элемент)
	
	Если НавигацияПоВремени=0 Тогда
		Возврат;
	КонецЕсли;
	
	мОтбор = новый Структура("ДатаВремя",ПозицияПоВремени);
	н_строки = ТаблицаАнализа.НайтиСтроки(мОтбор);
	Если н_строки.Количество()>0 Тогда
		шаг=н_строки[0].НомерШага-1+НавигацияПоВремени;
		Если шаг<0 Тогда
			шаг=0;
		ИначеЕсли шаг>ТаблицаАнализа.Количество()-1 Тогда
			шаг=ТаблицаАнализа.Количество()-1;
		КонецЕсли;
		ПозицияПоВремени = ТаблицаАнализа[шаг].ДатаВремя; 
	КонецЕсли;
	НавигацияПоВремени = 0;
	СформироватьШлейфХвостаSOM();
КонецПроцедуры

&НаКлиенте
Процедура ВернутьсяКПредыдущейШиринеОкна(Команда)
	Если КешПараметров.Получить("ПредИнтервалНачало")=Неопределено Тогда
		Возврат;
	КонецЕсли;
	ИнтервалНачало = КешПараметров.Получить("ПредИнтервалНачало");
	ИнтервалОкончание = КешПараметров.Получить("ПредИнтервалОкончание");
	ДатаНачалаИзБазы=ИнтервалНачало-Секунда(ИнтервалНачало);
	ИнтервалИзБазы=(ИнтервалОкончание-Секунда(ИнтервалОкончание))-ДатаНачалаИзБазы;
	ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
КонецПроцедуры

&НаКлиенте
Процедура НаложитьМодельНаГрафикИзБазыПриИзменении(Элемент)
	ОбновитьГрафикИсторииКлиент(ДатаНачалаИзБазы,ИнтервалИзБазы);
КонецПроцедуры



#КонецОбласти